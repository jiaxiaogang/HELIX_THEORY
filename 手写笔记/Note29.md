# 回测防撞训练 & 继续觅食训练

***

<!-- TOC -->

- [回测防撞训练 & 继续觅食训练](#回测防撞训练--继续觅食训练)
  - [n29p01 回测迁移性和防撞训练](#n29p01-回测迁移性和防撞训练)
  - [n29p02 共同点抽象1: `场景Fo外类比`、`Canset外类比(未完成)`](#n29p02-共同点抽象1-场景fo外类比canset外类比未完成)
  - [n29p03 共同点抽象2: `空概念类比`、`absCanset的初始SP和EFF`](#n29p03-共同点抽象2-空概念类比abscanset的初始sp和eff)
  - [n29p04 共同点抽象3: `边回测边改涉及决策需要的改动`](#n29p04-共同点抽象3-边回测边改涉及决策需要的改动)

<!-- /TOC -->

***

## n29p01 回测迁移性和防撞训练
`CreateTime 2023.03.20`

在n28末，做了Canset迁移性,本节通过防撞训练来回测;

| 29011 | 回测迁移性挂在所有pFos下: pFos有不全的问题 |
| --- | --- |
| 训练 | 根据防撞前两步训练; |
| 问题 | 发现`canset挂在所有pFos下`,竟然不包含触发者selfPFo本身; |
| 调试 | 经查,构建pFo时,pFo在baseRDemand下,只是后来应该什么时候被删了,需要明天继续查下; |
| 查明 | 在forecast中,pFo先失效,后调用的生成Canset,导致生成时此pFo已经失效未加上Canset; |
| 修复 | 改为先生成Canset,再设pFo为失效后好了 `T`; |

**29012-关于Canset迁移效率太低的问题**
1. 测试: 经29011测试中发现: 其实每条pFo都会生成一次Canset;而它们生成的Canset也大致是相同的,只是触发有先后而已;
2. 回测失败: 那我们上节中,将新Canset挂到所有pFos下,作用其实不大……(改动前的问题会依旧);
3. 分析原因: 现通过pFos传递经验的方案,只能邻近传递;
4. 反证观点: 那么在试错时,如果不邻近呢?肯定传递失败…即:我们假设能成功并且大胆尝试不够;
5. 本质问题: 即迁移效率不够 (总不能等被撞死几十回,才普及这个可能有效的经验到各处);
6. 解决方案: 所以,我们还是需要用特征影响不大,来构建抽象方案… (其实相邻宏微带来的定义不一致问题,大可以通过EFF来辅正);

名词说明: 本文构建抽象的问题,在下面统一命名为:"共同点抽象";

```java
29013-在29012中,第1,2,3,4是猜想,本表先实训`防撞前两步`验证如下:
R新Canset:F562[A559(高100,皮0,向19,距117)] (状态:无反馈 fromPFo:F336 帧:1) 挂pFos下:(F489,F415,F557,F336)
R新Canset:F563[A559(高100,皮0,向19,距117)] (状态:无反馈 fromPFo:F557 帧:1) 挂pFos下:(F489,F415,F557)
R新Canset:F564[A559(高100,皮0,向19,距117)] (状态:无反馈 fromPFo:F489 帧:1) 挂pFos下:(F489,F415)
R新Canset:F565[A559(高100,皮0,向19,距117)] (状态:无反馈 fromPFo:F415 帧:1) 挂pFos下:()
结果: 如上日志,验证猜想成立,执行29012-6的解决方案;
```

本节测得上节做的Canset迁移性没什么用,我们回滚下代码,然后经分析: Canset迁移不足的问题,还是要通过构建"共同点抽象"来解决,转下节继续;

***

## n29p02 共同点抽象1: `场景Fo外类比`、`Canset外类比(未完成)`
`CreateTime 2023.03.21`

本节针对上节29012-解决方案,本节做"共同点抽象"的方案分析与代码实践;

**警告: 本节将面临大改,因为要将外类比共同点抽象打开,整个网络抽具象层级,和决策时下向性,也要相应的兼容多层;**
> 大改原由: 触发本次大改的原因,是Canset的迁移性不足: 即,我们要对各种距离段都训练一次正确的canset才工作顺利,这显然不行,所以提升迁移性是必须要做的,这里记录一下本次大改的原因;

| 29021 | 执行前的准备工作-反思下做抽象会不会有什么问题 |
| --- | --- |
| 问题1 | **这会不会导致过度抽象问题 (参考28186-方案2-追问);** |
|  | 答: 抽具象多层多样性一直在生效,所以不可能过度抽象; |
|  | 证: 而现在的情况,洽洽是(缺少共同点抽象)抽象的缺失问题; |
| 问题2 | **这会不会太复杂? (参考28186-方案2-追问);** |
|  | 答: 会复杂,但必要性大,需求明确,可做; |
| 结果 | 28186-方案2-追问,提到的问题,在本表都做了解答,下表可以正式放开干了; |

| 29022 | 共同点抽象-方案规划 |
| --- | --- |
| 方案1 | **根据Canset反推抽象概念 `5%`;** |
| 自辩 | 1. 正向(左向右)是很难获取`无距棒`的,因为输入端必定各特征齐全; |
|  | 2. 要想得到`无距棒`除非特征一致,但输入端几乎没有一致的情况; |
|  | 3. 全在决策端,根据`强化统计`的一致性,来反向判断特征有类似功效却是可以的; |
|  | 4. 反推抽象概念方案,以增强Canset迁移性,就是利用这一方式来达成的; |
| 优点 | 更精准; |
| 缺点 | 但也更复杂; |
| 缺陷 | 这里比对Canset的共同点,但并不表示也是场景的共同点 |
|  | 缺陷说明: Canset的共同点,与场景的共同点,二者间的衔接是个未接上的坑; |
| 点评 | 此方案不符合向性原则,且缺陷也难以填上 `5%`; |
| 方案2 | **用以前的外类比来达成 `95%`;** |
| 自辩 | 1. 用原来的外类比: 相近度高的计做sames,然后抽象之; |
|  | 2. 想得到`无距棒`并不必须特征一致,只要码相近也是ok的; |
|  | 3. 共右向性在认知期来实现`共同点抽象`,更符合认知层是右向性的原则; |
|  | 4. 以认知期`共同点抽象`,来带动Canset时的迁移性,此方案看来更好; |
| 优点 | 效果更广而全面，迁移性更强,也符合认知的向性原则。 |
| 缺点 | 带来混乱度也高 (但好在决策期的竞争机制就是专门克服这里的混乱度的); |
| 缺陷 | 场景变抽象,但它下面的Canset却并不抽象,本方案需要连带解决此问题; |
|  | 缺陷说明: 如果Canset不抽象,它的EFF计数就很难累加; |
| 点评 | 本方案符合向性原则,缺点可解,缺陷看起来也更容易解决 `95%`; |
| 结果 | 参考二者的点评,选定方案2,但需要先解决缺陷 `转29023`; |

| 29023 | 共同点抽象-方案2-缺陷解决分析 |
| --- | --- |
| 分析1 | 可以将Canset改成由protoFo的抽象来构建? |
|  | a. matchFo下包含的,用matchFo的帧来即可; |
|  | b. matchFo下不包含的,则使用matchAlgs中较为抽象的alg来? `转示例-2问题` |
|  | 解析: 即最好是层级跟随: 即在怎样的场景抽具象层级上,Canset就是怎样的抽具象层级 |
| 方案 | **将Canset由protoFo构建改为使用抽象来组建 (抽象层级跟随matchFo);** |
| 疑问1 | 有些帧,不在matchFo中,是层级跟随不到的,需要分析下此问题,如下: |
| 示例 | 比如: 想吃苹果的时候就买个苹果,想吃水果的时候只要是个水果就行; |
|  | 1. 可跟随: 上例中的`苹果和水果`,在场景fo中有包含,所以能够向场景跟随; |
|  | 2. 问题: 无法跟随问题: 但`买`的动作是无法向场景跟随的,因为场景fo中,没有`买`; |
| 思路 | 此问题`场景Fo不包含的`,可以用protoAlg,然后在使用Canset时: `此思路采纳` |
|  | 1. 场景Fo包含的严格要求isCansetAlg(是它); |
|  | 2. 而场景Fo不包含的,反馈cansetAlgIs(它的抽象)即可; |
|  | 3. 场景不包含的: 也可考虑存成matchAlgs数组 (protoAlg识别到的matchAlgs)? |
|  | 追加: 此思路-2判为错误,见以下`做饭`例子,即是反例 `此思路错误,废弃`; |
|  | 追加: 平反,此思路-2并不错误,只是它需要从具象向抽象的成长流程 `转29024-步骤`; |
| 例1 | 遇到危险时,躲开即可,这里的躲就在canset中,却不在场景fo中; |
| 例2 | 具象场景fo[想吃批萨]->对应Canset[做批萨],抽象场景fo[想吃饭]->对应Canset[做饭]; |
|  | 分析: 我们尝试去自省这里的躲和做是什么,却很难自省明白 (因为它很抽象); |
|  | 说明: 做饭的"做"在批萨时是`烤`,在凉菜时是`拌`,而躲开的躲在防撞时是`飞`,在打游戏时是`按左`; |
| 所以 | **1. 抽象Canset不执行,真正执行的是具象canset;** |
|  | **2. 基于抽具象canset的关联: eff计数时具象canset和抽象canset都+1;** |
| 结果 | matchFo在pLearning时触发外类比抽象,那Canset什么时候触发类比抽象? `转29024` |
| 结果2 | 构建新Canset时,场景包含的用matchAlg,不包含的用protoAlg `转29024-步骤3&5`; |

**28923总结,29024前说明:**
1. 29023中,构建新Canset时,场景fo不包含的帧,暂用了protoAlg;
2. 但29023的例中可见:`做和躲`都是抽象的,并不具象;
3. 那是因为它们一开始确实是具象的,只是后面又在别的流程中抽象了而已;
4. 在29024中,重点分析Canset的这一抽象流程;

| 29024 | 那Canset什么时候触发类比抽象? |
| --- | --- |
| 问题说明 | 参考上表结果,抽象Canset不执行,只是执行具象Canset,那么什么时候构建抽具象Canset的关联? |
| 步骤 | 以下模拟一下HE跑起来的步骤,重现一下Canset会什么时候类比抽象; |
| 1. | pLearning触发外类比,构建抽象matchFo: F1[想吃饭]; |
| 2. | 下一次识别到具象些的F2[想吃批萨],和更抽象的F1[想吃饭]; |
| 3. | 烤批萨吃后,此时F1触发器发现没更饿,生成新Canset F3[烤饭吃] (其中饭在F1含,烤不含); |
| 4. | 下二次识别到具象些的F4[想吃拌凉菜],和更抽象的F1[想吃饭]; |
| 5. | 拌凉菜吃后,此时F1触发器又没更饿,又生成新Canset F5[拌饭吃] (其中饭在F1含,拌不含); |
| 6. | 将F3和F5进行类比,得到抽象Canset F6[做饭吃]; |
| 总结 | 其中步骤6,前段时间正好在28182-todo6写了cansetFo识别算法,改改就能用; |
|  | 设想: 判断`烤`和`拌`有没有共同的抽象absAlg,有的话即二者全含; |
|  | 比如: 新[1,3,5,7,9a]和旧[1,5,9b]和场景[1,5] = 是全含的,并最终返回<1:1, 2:3, 3:5>; //其中9a和9b有共同抽象 |
|  | 类比: 然后在识别完成后: 类比时,直接将二者做类比即可,有哪些共同点算哪些; |
| 结果 | 本表彻底解决了29022-方案2的缺陷,后面可以转29025进行实践规划了 `转29025`; |

**小结: 29024通过模拟跑起来的步骤,明确了Canse识别部分,和触发类比 (但类比并未深入,只写出了`有哪些共同点算哪些`)**

| 29025 | 共同点抽象-方案2-实践前规划 |
| --- | --- |
| 说明 | 本轮实践分为: `场景fo外类比`,`Canset抽象`,`决策时兼容多层抽具象`几大部分; |
| (一) | 场景fo外类比部分 `T`: |
| 11. 恢复外类比 | 现在的外类比是无效状态，可以在这次尝试打开它！`T`; |
| 12. 概念类比 | 在Analogy中,支持概念类比,概念类比再计算每个码分别为匹配度担多少责任 `T`; |
| 13. V的责任计算 | 如果一个码责任>50%,为主要责任,那么就把它抽象掉 `T`; |
|  | > 比如:三个码:1x0.8x0.7时,当前码=0.7时,它的责任比例=(1-0.7)/(1-0.8 + 1-0.7)=60% `T` |
| (二) | Canset抽象部分: |
| 21. 用抽象生成新Canset | 场景包含的: 层级跟随的用matchAlg填充 `参考29023-思路1` `T`; |
| 22. 用抽象生成新Canset | 场景不包含的: 用protoAlg填充 `参考29024-步骤3&5` `T`; |
| 23. 迭代Canset识别 | 将Canset时序识别算法迭代下,支持下`新旧Canset的全含判断` `参考29024-设想` `T` |
|  | 23a. 新Canset必须全含旧的Canset,缺一帧都不行 `T`; |
|  | 23b. 全含判断: 新旧帧都被matchFo场景的同一帧包含,则此帧全含通过 `T`; |
|  | 23b2. 新旧帧其中之一被场景包含,则整体全含判断失败 `T`; |
|  | 23c. 新旧全不被matchFo包含时,应判断新旧帧有没有共同的抽象,有则此帧全含 `T`; |
|  | 23c2. 如果没有共同抽象,继续找newCanset的下一帧,看能不能有共同抽象 `T`; |
|  | 23c3. 直到下帧newCanset被matchFo包含时,如果还没共同抽象,则整体全含失败 `T`; |
|  | 23d. 单帧成功时,记录到返回的`全含结果indexDic`中 `以前就有的逻辑 T`; |
|  | 23e. 只要有一帧失败,则全含整体失败 `以前就有的逻辑 T`; |
|  | 23f. 所有帧都全含成功了,则整体全含成功,并返回收集起来的indexDic `以前就有的逻辑 T`; |
| 24. 识别后新旧Canset类比 | Canset时序识别算法后,支持CansetLearning(),就是外类比下 `参考29024-类比` `T` |
|  | 24a. 直接根据全含输出的新旧indexDic映射来进行时序类比 `T`; |
|  | 24b. 支持下场景包含帧的类比: `直接Equal判断,因为它们是同一场景的同一元素` `T`; |
| 25. 场景不包含帧的类比 | 比如:`烤和拌的类比抽象`,二者有共同抽象,它们的类比方式是什么? `转29026` |
| (三) | 决策时兼容多层抽具象 `先不写,等写完前两个,在实测中发现问题时,再顺着问题改决策` `转后面实测时做` |

**小结: 29025做了场景fo外类比,以及优先用抽象alg生成Canset,以及Canset识别部分**
1. 但场景不包含帧的Canset类比未写,转下面两张继续深入分析一下 `在n29p03完成了 T`;
2. 决策也没写,转实测时边测边明确了需求时再跟着写 `转n29p04边测边搞`;

| 29026 | 场景不包含Canset帧的类比-初步方案分析 A |
| --- | --- |
| 方案1 | 将AB帧的相似点抽象出来 `5%` |
|  | 分析: 它的起因是有共同抽象,这个类比结果要随时加入别的新Canset相应帧; |
|  | 那么: 那么再有新Canset对应帧不断加入时,判断相似度的参考标准就一直在变; |
|  | 而这个抽象帧,需要应对这一切的变化,都能挂给它当具象,还都得相似?除非直接用空抽象,转方案2; |
| 方案2 | 直接用空概念当类比抽象结果 `95%`; |
|  | 分析: 这个空概念的意义解释依赖它指向的具象,所以它不能全局去重,不然挂几万个各种具象就跪了; |
| 结果 | 选定方案2 `但空概念的防重等细节还需要继续分析,转29027`; |

| 29027 | 场景不包含Canset帧类比出空方案-细节方案分析 B |
| --- | --- |
| 问题 | 要避免这个空概念过度复用,导致下面挂几万个各种具象; |
| 方案1 | 越来越并集方案; |
|  | 说明: 根据`matchFo.pId`和`matchFo.index`来防重,这样就完美的指向了这个场景下的这一帧; |
|  | 代码: 直接用场景PID当dataSource,然后用index当algsType,即可; |
|  | 缺陷: 因为有共同抽象的传递问题 (有时共同抽象是打,有时是推,有时是摸),这种迟早变成并集; |
|  | 所以: 最好是让生成的空抽象,不要超过目前的`共同抽象集`,它只能越来越交集,而不是越来越并集; |
| 方案2 | 直接最交集方案: 如果共同抽象有4条,那么就分别构建4条; |
|  | 分析: 这种是另一个极端: 属于一步达到最交集状态了; |
|  | 缺陷: 如果3a有4条共同抽象,9a有5种,难道要一次构建20条抽象Canset? |
|  | 所以: 这种一次性最交集方式不现实,各种细分许多条,交叉在一块,乱成一锅; |
| 方案3 | 越来越交集方案; |
|  | 分析: 此方案一开始生成一个`指向多条共同抽象的空概念`,后面随着此步骤再触发,变的越来越交集,指向的共同抽象越来越少; |
|  | 细节: `1.抽象指向4条共同抽象 2.ds用共同抽象的pidArr 3.不用at=matchFo.index了(因为这方案能支持全局防重了)` |
|  | 说明: 允许它全局防重 (空概念的抽象指向明确了它的含义,用在哪个场景下含义都不变,而各场景不同归场景管,不归它管); |
|  | 示图: ![](assets/678_Canset类比空概念越来越交集方案示图.png) |
|  | 越来越交集步骤说明: `1.3a3b生成如上图空概念 2.下次此空概念可能做为另一个3a即可越来越交集;` |
|  | 优点: `前期空概念的cansetFo`会将SP和EFF传递给越来越抽象的`后期空概念cansetFo`; |
| 结果 | 选定方案3,代码实践`转n29p03`; |

**小结: 29026-29027分析了场景不包含帧的Canset类比方案,最终结果参考29027方案3**

总结:
1. 本节迭代支持了场景外类比(共同点抽象);
2. 新Canset改优先为用抽象alg来生成;
3. 迭代了CansetFo识别算法 (及全含判断方式);
4. 写了Canset类比器 (其中matchFo未包含帧的类比未完成);
5. 分析了matchFo不包含帧的类比方案 `参考29027-方案3`;

***

## n29p03 共同点抽象2: `空概念类比`、`absCanset的初始SP和EFF`
`CreateTime 2023.03.25`

本节顺着上节末尾的`matchFo不包含帧的类比`继续进行代码实践;

| 29031 | 场景不包含Canset帧类比-29027方案3-代码实践规划 |
| --- | --- |
| todo1 | 直接构建空概念当抽象 `T`; |
| todo1.1 | 空概念用ds防重 (ds=共同抽象的pointerIds组成字符串) `T`; |
| todo2 | 新空概念的具象指向3a,3b `T`; |
| todo3 | 新空概念的抽象指向`共同抽象集` `T`; |

| 29032 | 构建absCansetFo后,需要继承SP和EFF-方案规划与实践TODOLIST |
| --- | --- |
| 说明 | 上表做了不包含帧的类比,类比写完了,本表要针对类比后构建抽象需要改什么 (主要需要加上继承SP和EFF); |
| 分析 | 关于继承哪些SP和EFF,以下分析: |
| 1 | 如果absCanset是复用的,非新建: |
|  | a. 如果旧Canset本来就指向它了,则将抽象cansetFo的SP和EFF+1就行吧? |
|  | b. 如果旧Canset是新指向它的 (那么就把旧cansetFo的SP和EFF都累计给absCanset); |
| 2 | 如果absCanset本来没有,新建的: |
|  | a. 此时直接将旧Canset的Sp和EFF累计给absCanset; |
| 方案 | 根据以上分析可得,只要absFo和conFo之间是新关联,即继承它的sp和eff (两个conFo都这样处理); |
| 实践 | 实践规划: 在absCanset的构建方法里,支持下继承SP和EFF; |
| todo1 | 将两处调用createAbsFo_NoRepeat的地方,都收集起来conFos和absFo的indexDic,然后传到构建absFo方法中 `T`; |
| todo1.1 | 新旧Canset映射为<1:3,2:5,4:7>时,newIndexDic=<1:3,2:5,3:7>,oldIndexDic=<1:1,2:2,3:4> `T`; |
|  | 示例: canset类比计算indexDic的示例: 其中canset类比抽象时,比如newCanset和oldCanset映射为<1:3,2:5,4:7>; |
| todo1.2 | analogyOutside外类比时,也要支持生成protoIndexDic和assIndexDic两个映射字典 `T`; |
| todo2 | 构建抽象absFo后,要根据具象Fo更新下absFo的sp和eff (分为继承assFo的和后续+1两种更新如下:) `T`; |
| todo2.1 | 根据分析1&2,判断absFo和assFo之间是否新关联 `T`; |
| todo2.2 | assFo和absFo未关联,则先继承assFo的sp和EFF `T`; |
| todo2.3 | protoCansetFo给absFo带来SP和EFF的+1 (因为protoCansetFo刚发生一次) `T`; |
| todo2.4 | Canset外类比需要更新EFF,但普通外类比不需要更新EFF `T`; |
| todo3 | 将conFo的indexDic映射也存到新absFo上 `T`; |

**总结: 本节完成了共同点抽象的:**
1. 29027-方案3: matchFo不包含帧的类比;
2. 构建absCansetFo后,继承与更新它的SP和EFF;

***

## n29p04 共同点抽象3: `边回测边改涉及决策需要的改动`
`CreateTime 2023.03.28`

接29025-(三),本文边回测前两节带来的迁移性改进,边看需要改决策哪些部分;

| 29041 | 回测 |
| --- | --- |

<br><br><br><br><br>
