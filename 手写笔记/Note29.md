# 回测防撞训练 & 继续觅食训练

***

<!-- TOC -->

- [回测防撞训练 & 继续觅食训练](#回测防撞训练--继续觅食训练)
  - [n29p01 回测迁移性和防撞训练](#n29p01-回测迁移性和防撞训练)

<!-- /TOC -->

***

## n29p01 回测迁移性和防撞训练
`CreateTime 2023.03.20`

在n28末，做了Canset迁移性,本节通过防撞训练来回测;

| 29011 | 回测迁移性挂在所有pFos下: pFos有不全的问题 |
| --- | --- |
| 训练 | 根据防撞前两步训练; |
| 问题 | 发现`canset挂在所有pFos下`,竟然不包含触发者selfPFo本身; |
| 调试 | 经查,构建pFo时,pFo在baseRDemand下,只是后来应该什么时候被删了,需要明天继续查下; |
| 查明 | 在forecast中,pFo先失效,后调用的生成Canset,导致生成时此pFo已经失效未加上Canset; |
| 修复 | 改为先生成Canset,再设pFo为失效后好了 `T`; |

**29012-关于Canset迁移效率太低的问题**
1. 测试: 经29011测试中发现: 其实每条pFo都会生成一次Canset;而它们生成的Canset也大致是相同的,只是触发有先后而已;
2. 回测失败: 那我们上节中,将新Canset挂到所有pFos下,作用其实不大……(改动前的问题会依旧);
3. 分析原因: 现通过pFos传递经验的方案,只能邻近传递;
4. 反证观点: 那么在试错时,如果不邻近呢?肯定传递失败…即:我们假设能成功并且大胆尝试不够;
5. 本质问题: 即迁移效率不够 (总不能等被撞死几十回,才普及这个可能有效的经验到各处);
6. 解决方案: 所以,我们还是需要用特征影响不大,来构建抽象方案… (其实相邻宏微带来的定义不一致问题,大可以通过EFF来辅正);

名词说明: 本文构建抽象的问题,在下面统一命名为:"共同点抽象";

```java
29013-在29012中,第1,2,3,4是猜想,本表先实训`防撞前两步`验证如下:
R新Canset:F562[A559(高100,皮0,向19,距117)] (状态:无反馈 fromPFo:F336 帧:1) 挂pFos下:(F489,F415,F557,F336)
R新Canset:F563[A559(高100,皮0,向19,距117)] (状态:无反馈 fromPFo:F557 帧:1) 挂pFos下:(F489,F415,F557)
R新Canset:F564[A559(高100,皮0,向19,距117)] (状态:无反馈 fromPFo:F489 帧:1) 挂pFos下:(F489,F415)
R新Canset:F565[A559(高100,皮0,向19,距117)] (状态:无反馈 fromPFo:F415 帧:1) 挂pFos下:()
结果: 如上日志,验证猜想成立,执行29012-6的解决方案;
```

本节测得上节做的Canset迁移性没什么用,我们回滚下代码,然后经分析: Canset迁移不足的问题,还是要通过构建"共同点抽象"来解决,转下节继续;

***

## n29p02 共同点抽象
`CreateTime 2023.03.21`

本节针对上节29012-解决方案,本节做"共同点抽象"的方案分析与代码实践;

**警告: 本节将面临大改,因为要将外类比共同点抽象打开,整个网络抽具象层级,和决策时下向性,也要相应的兼容多层;**
> 大改原由: 触发本次大改的原因,是Canset的迁移性不足: 即,我们要对各种距离段都训练一次正确的canset才工作顺利,这显然不行,所以提升迁移性是必须要做的,这里记录一下本次大改的原因;

| 29021 | 执行前的准备工作-反思下做抽象会不会有什么问题 |
| --- | --- |
| 问题1 | **这会不会导致过度抽象问题 (参考28186-方案2-追问);** |
|  | 答: 抽具象多层多样性一直在生效,所以不可能过度抽象; |
|  | 证: 而现在的情况,洽洽是(缺少共同点抽象)抽象的缺失问题; |
| 问题2 | **这会不会太复杂? (参考28186-方案2-追问);** |
|  | 答: 会复杂,但必要性大,需求明确,可做; |
| 结果 | 28186-方案2-追问,提到的问题,在本表都做了解答,下表可以正式放开干了; |

| 29022 | 共同点抽象-方案规划 |
| --- | --- |
| 方案1 | **根据Canset反推抽象概念 `5%`;** |
| 自辩 | 1. 正向(左向右)是很难获取`无距棒`的,因为输入端必定各特征齐全; |
|  | 2. 要想得到`无距棒`除非特征一致,但输入端几乎没有一致的情况; |
|  | 3. 全在决策端,根据`强化统计`的一致性,来反向判断特征有类似功效却是可以的; |
|  | 4. 反推抽象概念方案,以增强Canset迁移性,就是利用这一方式来达成的; |
| 优点 | 更精准; |
| 缺点 | 但也更复杂; |
| 缺陷 | 这里比对Canset的共同点,但并不表示也是场景的共同点 |
|  | 缺陷说明: Canset的共同点,与场景的共同点,二者间的衔接是个未接上的坑; |
| 点评 | 此方案不符合向性原则,且缺陷也难以填上 `5%`; |
| 方案2 | **用以前的外类比来达成 `95%`;** |
| 自辩 | 1. 用原来的外类比: 相近度高的计做sames,然后抽象之; |
|  | 2. 想得到`无距棒`并不必须特征一致,只要码相近也是ok的; |
|  | 3. 共右向性在认知期来实现`共同点抽象`,更符合认知层是右向性的原则; |
|  | 4. 以认知期`共同点抽象`,来带动Canset时的迁移性,此方案看来更好; |
| 优点 | 效果更广而全面，迁移性更强,也符合认知的向性原则。 |
| 缺点 | 带来混乱度也高 (但好在决策期的竞争机制就是专门克服这里的混乱度的); |
| 缺陷 | 场景变抽象,但它下面的Canset却并不抽象,本方案需要连带解决此问题; |
|  | 缺陷说明: 如果Canset不抽象,它的EFF计数就很难累加; |
| 点评 | 本方案符合向性原则,缺点可解,缺陷看起来也更容易解决 `95%`; |
| 结果 | 参考二者的点评,选定方案2,但需要先解决缺陷 `转29023`; |

| 29023 | 共同点抽象-方案2-缺陷解决分析 |
| --- | --- |
| 分析1 | 可以将Canset改成由protoFo的抽象来构建? |
|  | a. matchFo下包含的,用matchFo的帧来即可; |
|  | b. matchFo下不包含的,则使用matchAlgs中较为抽象的alg来? `转示例-2问题` |
|  | 解析: 即最好是层级跟随: 即在怎样的场景抽具象层级上,Canset就是怎样的抽具象层级 |
| 方案 | **将Canset由protoFo构建改为使用抽象来组建 (抽象层级跟随matchFo);** |
| 疑问1 | 有些帧,不在matchFo中,是层级跟随不到的,需要分析下此问题,如下: |
| 示例 | 比如: 想吃苹果的时候就买个苹果,想吃水果的时候只要是个水果就行; |
|  | 1. 可跟随: 上例中的`苹果和水果`,在场景fo中有包含,所以能够向场景跟随; |
|  | 2. 问题: 无法跟随问题: 但`买`的动作是无法向场景跟随的,因为场景fo中,没有`买`; |
| 思路 | 此问题`场景Fo不包含的`,可以用protoAlg,然后在使用Canset时: `此思路采纳` |
|  | 1. 场景Fo包含的严格要求isCansetAlg(是它); |
|  | 2. 而场景Fo不包含的,反馈cansetAlgIs(它的抽象)即可; |
|  | 3. 场景不包含的: 也可考虑存成matchAlgs数组 (protoAlg识别到的matchAlgs)? |
|  | 追加: 此思路-2判为错误,见以下`做饭`例子,即是反例 `此思路错误,废弃`; |
|  | 追加: 平反,此思路-2并不错误,只是它需要从具象向抽象的成长流程 `转29024-步骤`; |
| 例1 | 遇到危险时,躲开即可,这里的躲就在canset中,却不在场景fo中; |
| 例2 | 具象场景fo[想吃批萨]->对应Canset[做批萨],抽象场景fo[想吃饭]->对应Canset[做饭]; |
|  | 分析: 我们尝试去自省这里的躲和做是什么,却很难自省明白 (因为它很抽象); |
|  | 说明: 做饭的"做"在批萨时是`烤`,在凉菜时是`拌`,而躲开的躲在防撞时是`飞`,在打游戏时是`按左`; |
| 所以 | **1. 抽象Canset不执行,真正执行的是具象canset;** |
|  | **2. 基于抽具象canset的关联: eff计数时具象canset和抽象canset都+1;** |
| 结果 | matchFo在pLearning时触发外类比抽象,那Canset什么时候触发类比抽象? `转29024` |
| 结果2 | 构建新Canset时,场景包含的用matchAlg,不包含的用protoAlg `转29024-步骤3&5`; |

**28923总结,29024前说明:**
1. 29023中,构建新Canset时,场景fo不包含的帧,暂用了protoAlg;
2. 但29023的例中可见:`做和躲`都是抽象的,并不具象;
3. 那是因为它们一开始确实是具象的,只是后面又在别的流程中抽象了而已;
4. 在29024中,重点分析Canset的这一抽象流程;

| 29024 | 那Canset什么时候触发类比抽象? |
| --- | --- |
| 问题说明 | 参考上表结果,抽象Canset不执行,只是执行具象Canset,那么什么时候构建抽具象Canset的关联? |
| 步骤 | 以下模拟一下HE跑起来的步骤,重现一下Canset会什么时候类比抽象; |
| 1. | pLearning触发外类比,构建抽象matchFo: F1[想吃饭]; |
| 2. | 下一次识别到具象些的F2[想吃批萨],和更抽象的F1[想吃饭]; |
| 3. | 烤批萨吃后,此时F1触发器发现没更饿,生成新Canset F3[烤饭吃] (其中饭在F1含,烤不含); |
| 4. | 下二次识别到具象些的F4[想吃拌凉菜],和更抽象的F1[想吃饭]; |
| 5. | 拌凉菜吃后,此时F1触发器又没更饿,又生成新Canset F5[拌饭吃] (其中饭在F1含,拌不含); |
| 6. | 将F3和F5进行类比,得到抽象Canset F6[做饭吃]; |
| 总结 | 其中步骤6,前段时间正好在28182-todo6写了cansetFo识别算法,改改就能用; |
|  | 设想: 判断`烤`和`拌`有没有共同的抽象absAlg,有的话即二者全含; |
|  | 类比: 然后在识别完成后: 类比时,直接将二者做类比即可,有哪些共同点算哪些; |
| 结果 | 本表彻底解决了29022-方案2的缺陷,后面可以转29025进行实践规划了 `转29025`; |

| 29025 | 共同点抽象-方案2-实践前规划 |
| --- | --- |
| 说明 | 本轮实践分为: `场景fo外类比`,`Canset抽象`,`决策时兼容多层抽具象`几大部分; |
| (一) | 场景fo外类比部分 `T`: |
| 11. 恢复外类比 | 现在的外类比是无效状态，可以在这次尝试打开它！`T`; |
| 12. 概念类比 | 在Analogy中,支持概念类比,概念类比再计算每个码分别为匹配度担多少责任 `T`; |
| 13. V的责任计算 | 如果一个码责任>50%,为主要责任,那么就把它抽象掉 `T`; |
|  | > 比如:三个码:1x0.8x0.7时,当前码=0.7时,它的责任比例=(1-0.7)/(1-0.8 + 1-0.7)=60% `T` |
| (二) | Canset抽象部分: |
| 21. 用抽象生成新Canset | 场景包含的: 层级跟随的用matchAlg填充 `参考29023-思路1` `T`; |
| 22. 用抽象生成新Canset | 场景不包含的: 用protoAlg填充 `参考29024-步骤3&5` `T`; |
| 23. 迭代Canset识别 | 将Canset时序识别算法迭代下,支持下`新旧Canset的全含判断` `参考29024-设想` |
| 24. 场景不含帧的类比抽象 | 将Canset时序识别算法迭代下,支持下`烤和拌的类比抽象` `参考29024-类比` |

<br><br><br><br><br>
