# 去皮训练: 学去皮

***

<!-- TOC -->

- [去皮训练: 学去皮](#去皮训练-学去皮)
  - [n31p01 去皮训练-学会去皮部分6 (规划搬运训练步骤 & 学会搬运带皮果)](#n31p01-去皮训练-学会去皮部分6-规划搬运训练步骤--学会搬运带皮果)
  - [n31p02 TO类似任务执行太多次问题: 同质Root合并](#n31p02-to类似任务执行太多次问题-同质root合并)
  - [n31p02b TO第2步转为候选集巨慢优化](#n31p02b-to第2步转为候选集巨慢优化)
  - [n31p02c 学会搬运](#n31p02c-学会搬运)
  - [n31p05 运用搬运](#n31p05-运用搬运)
  - [n31p06 重跑学搬运](#n31p06-重跑学搬运)
  - [n31pN TODO备忘](#n31pn-todo备忘)

<!-- /TOC -->

***

## n31p01 去皮训练-学会去皮部分6 (规划搬运训练步骤 & 学会搬运带皮果)
`CreateTime 2023.11.09`

| 31011 | 规划搬运训练,在目前的基础上,训练学会搬运有皮果: 搬运动机部分 |
| --- | --- |
| 简介 | 本表主要解决`搬运`动机问题: 当发现压不到坚果时,搬运后,能压到了 (并将此经验记录成HCanset); |
| 分析 | 1. 木棒确实不可被hCanset实现,但仍可以预测: 即使有木棒,它有些情况下也压不到的; |
|  | 2. 先测下,在压不到的情况下,它是否会预测到这种情况是压不到的 (在30145-步骤4已经训练了各种能否压到的情况); |
| 调试 | 1. 生成任务日志: `pFo:F947[M1{↑饿-16},A944(距72,向182,皮果)]->{-16.00}` |
|  | 2. 找到R解日志: `I<F947 F8544[M1{↑饿-16},A944(距72,向182,皮果),A6552(距121,向17,棒)]> {2 = S0P2;}` |
|  | 思路: 根据以上日志可见,在什么场景下能不能压的到,并不是matchFos预测得到的,而是rCanset的SP稳定性计数出来的; |
| 原则 | **搬运动机源于: 对Canset追求更高的SP稳定性;** |
| 测下 | 在FZ885的基础上再跑跑`30145-步骤4`,看下日志,能不能激活rCanset,然后增强SP? `具体测的跟进,转以下几张表` |

**小结: 31011分析了搬运动机,但被下方几张表的BUG卡住,所以搬运动机要转至31016再继续;**

```c
31012-木棒cansetA的deltaTime=0的问题;
//说明: 如下日志,rCanset能激活,也能顺利转到H任务A3568(棒),但问题在于,取到出现木棒的时间是0s,导致触发器很快,根本来不及等到feedbackTOR反馈;
_Fo行为化第 3/10 个: F4591[M1{↑饿-16},A159(向335,距60,皮果),A3568(向331,距56,棒),A3572(向274,距27,棒)...
---//构建行为化帧触发器:0x600000643b10 for:饿 time:0.00
_Fo行为化第 3/10 个: F4026[M1{↑饿-16},A384(向23,距67,皮果),A3568(向331,距56,棒),A3572(向274,距27,棒)...
---//构建行为化帧触发器:0x600000655c70 for:饿 time:0.00
_Fo行为化第 3/10 个: F4026[M1{↑饿-16},A384(向23,距67,皮果),A3568(向331,距56,棒),A3572(向274,距27,棒)...
---//构建行为化帧触发器:0x6000006b79d0 for:饿 time:0.00
//分析: 经查,在生成尤其决策期的一些fo时,比如cansetFo或者feedbackRegroupFo时,order的时间不是时间戳,而是本身就是deltaTime值;
//解答: 这导致在生成fo时,再次计算deltaTime,会算错,算成0,把输入时是输入时间戳还是已经是deltaTime加以区分,改后好了 `T`;
```

| 31013 | 改掉deltaTime=0的BUG后,重新训练步骤3到步骤5 |
| --- | --- |
| 简介 | 上表BUG修复后,因为这个BUG主要影响cansetFo生成和决策期,所以相关的就是步骤2到5,本表重新训练下这三步 |
| 注1 | 为了单纯训练去皮相关(避免疼痛影响它安静思考),本表将`随机出生`改为`随机路边出生`; |
| 步骤1 | **带皮学饿: 认知模式(`饿(持续饿感3次),扔随机带皮坚果,不吃,又饿`x200轮);** =>存为FZ871 |
| 步骤2 | **学认木棒: 认知模式(`随机路边出生,扔木棒` x 300轮);** =>存为FZ882 |
| 步骤3 | **带皮学吃: 认知模式(`饿,路边出生,路上就近扔带皮果,扔棒去皮,手动飞过去,触发吃掉`)x近中远上下各1次** =>存为FZ893 |
|  | > 重点日志: 看下`newRCanset`日志,应该能生成许多(避免更饿)RCanset; |
| 步骤4 | **学H去皮: 动物模式(`随机路边出生,饿,扔随机带皮果,扔木棒`x200轮);** =>存为FZ894 |
|  | > 重点日志: 看下`newHCanset`日志,应该能生成许多(去皮)HCanset; |
| 步骤5 | **预想与实际类比: 动物模式(`步骤3一致`)x近中远上下各1次** (参考30154-测1) =>存为FZ895 |
|  | > 重点日志: 看下`预想与实际`日志,应该能类比生成许多抽象RCanset; |
| 结果 | 本表在FZ882的基础上重新训练下步骤3到5,并存为FZ893,FZ894,FZ895; |

**小结: 以上31012-31013修复了deltaTime=0的BUG,并重新训练了FZ893,894,895;**

```c
31014-在31013-步骤5训练时,发现"预想与实际类比"的结果不好,调试日志如下:
1. 新proto: F9190[M1{↑饿-16},A515(距32,向72,皮果),A9163(距82,向18,棒),A9168(距26,向90,棒),A9169(向98,距9,果),飞↑,A9177(距53,向160,棒),A9178(距0,向122,果),A9183(向163,距54,棒),A3547(吃1)]
2. 与ass: F8938[M1{↑饿-16},A515(距32,向72,皮果),A8912(距79,向17,棒),A8917(距23,向88,棒),A8918(向94,距10,果),飞↑]
3. 外类比构建时序: F9029[A13(饿16,7),A515(距32,向72,皮果),飞↑]->{} from: (protoFo(1):assFo(2))
RCanset预想与实际类比:F9029[A13(饿16,7),A515(距32,向72,皮果),飞↑] (curS:F8938 状态:Runing fromPFo:F518 帧:2)
//问题: 如上日志中,proto和ass还是挺相似的,但类比出的结果却没有`棒`,另外ass的末帧也没有收集到`吃`;
//复现: 用现在的`FZ895,近下出生,跑步骤3`,然后即可复现触发"预想与实际类比";
//分析: 应该是木棒确实mIsC没匹配上,毕竟现在的新木棒在似层能匹配上的机率很低(因为概念识别结果的条数少,而似层总数特别多);
//方案: 可以尝试下多跑跑步骤5,让Canset更多的触发类比,然后过度到交层,只要过度到交层了,此问题也就自然解决了;
//TODO1: 在同位置出生然后同样相对位置扔有皮果，然后跑步骤5，看能不能“预想与实际类比”出交层结果？训练日志如下：
第1行. RCanset预想与实际类比:F9029[A13(饿16,7),A515(距32,向72,皮果),飞↑] (curS:F8938 状态:Runing fromPFo:F518 帧:2)
第2行.RCanset预想与实际类比:F9267[A13(饿16,7),A515(距32,向72,皮果),A9266(距23,棒),飞↑] (curS:F8938 状态:Runing fromPFo:F518 帧:2)
第3行.RCanset预想与实际类比:F9303[A13(饿16,7),A515(距32,向72,皮果),A9302(向88,棒),飞↑] (curS:F8938 状态:Runing fromPFo:F518 帧:2)
第4行.RCanset预想与实际类比:F9303[A13(饿16,7),A515(距32,向72,皮果),A9302(向88,棒),飞↑] (curS:F8938 状态:ActNo fromPFo:F518 帧:2)
第5行.RCanset预想与实际类比:F9350[A13(饿16,7),A2528(距67,向141,皮果),A9349(距26,棒),A9348(距9,果),飞↑,A9347(距0,果),A3547(吃1)] (curS:F9192 状态:ActYes fromPFo:F2531 帧:2)
//结果: 从todo1训练日志可见，本表方案可以得到交层“无距棒、无向棒、无向果” `可将本表方案整理成训练步骤6,转31015`;
```

| 31015 | 预想与实际类比得到交层Canset -> 训练步骤6 |
| --- | --- |
| 步骤6 | **过渡到交层Canset: 动物模式(路边出生,饿,就近Y大致对齐路中扔皮果,扔棒,手动飞至,触发吃掉)x上下各5次** =>存为FZ896 |
|  | > 之所以要Y大致对齐,是为了让鸟和果的相对位置相对稳定,这样能帮助从似层快速过渡到交层; |
|  | > 重点日志: 看下`预想与实际`日志,应该能类比生成许多`交层Canset` (参考31014-方案&第5行日志); |

**小结: 31014-31015测得了抽象Canset因过度抽象缺失帧的问题,所以追加了训练步骤6,以训练交层Canset(交层能避免缺失帧问题);**

| 31016 | 搬运动机 -> 训练步骤7 |
| --- | --- |
| 简介 | 在31011分析了搬运动机的实现思路(其实就是给RCanset训练SP值),本表追加实际的训练步骤6,来试下; |
| 步骤7 | **搬运动机: 在FZ896基础上再跑跑步骤4** `参考31011-原则&测下` =>存为FZ897; |
|  | > 重点日志: 看下`OR反省`日志,rCanset的SP有增强; |
| 结果 | 比较稳定SP的Canset激活后,会显示[饿,路中带皮果,棒,无皮果,飞,吃],但可能带皮果不在路上呢?就需要搬运了 `转下表`; |

| 31017 | 搬运训练 -> 训练步骤8 |
| --- | --- |
| 简介 | 在31016-结果中指出了如果带皮果不在路上的情况,本表则针对此H需求做`学会搬运HCanset`; |
| 副目标 | 为快速达成训练目标,可以**尽量使用迁移和试错来学会搬运** (即只训练一两次hCanset,剩下的全用迁移和试错来完成); |
| 思路 | 1. 分析下RCanset需要什么距向的有皮果,然后生成为H任务后,把不符合的有皮果,搬运成符合的有皮果,并生成为hCanset; |
|  | 2. 这样下回再激活HDemand有皮果时,就可以找到hCanset经验,并尝试通过搬运来加工符合条件(搬到路上)的有皮果; |
| 前验 | **通过以下几步尝试,先提前验证一下上面的思路能不能跑的通;** |
|  | 说明: 主要验证**触发带皮果H任务,不符时,符合时,然后再试下能不能学会HCanset**,这4条都提前验证下; |
| 前验1 | 触发HDemand: 试下仅点击饿,能不能预测到更饿,然后得到rCanset,并将有皮果转成hDemand; |
|  | 问题1. 点击饥饿时,没有立马预测到更饿; |
|  | 解答1. 经查pInput时连概念识别都没调用,所以识别不到饿了会更饿,改先支持下,然后再测 `T`; |
|  | 问题2. 在饥饿调用概念识别时,全含检查全不通过; |
|  | 解答2. 因为mvAlg的count取contentPorts返回0,导致全含失败,改为用content_ps.count后返回2,全含能通过了 `T`; |
|  | 问题3. mv概念识别ok后,时序识别结果仍是0条; |
|  | 求解3. 经查,没有[饿]->{更饿}时序,导致识别不到,经查前7步从来没训练过[饿]->{更饿}; |
|  | 解答3. 可以在步骤2和步骤3之间先插入一步`饿了更饿`的训练 `转31018-步骤2.5`; |
|  | 问题4. 在31018-FZ907的基础上,点击饿发现: `饿了更饿`生成的任务无计可施,没有激活rCanset; |
|  | 求解4. 经查,饿了更饿没rCanset的原因是,手动训练时,点击重启太早,导致realMaskFo还未收集完成就重启了; |
|  | 解答4. 改为在看到思维闲时(TC的FPS为0持续三秒)再重启即可 `T`; |
| 前验2 | 符合时: 试下有皮果扔路上时H任务能反馈到; |
| 前验3 | 不符时: 然后再试下不扔到路上时,H任务反馈不到; |
| 前验4 | 学会HCanset: 然后再试下不扔到路上,但搬运到路上,然后又反馈到; |
| 步骤8 | **搬运训练: 动物模式(路下出生,路下扔带皮果,路上带皮果转为h任务后,把坚果搬运到路上,扔木棒,飞,吃)** |

**小结: 以上规划了"搬运动机"和"搬运训练",但搬运训练之前的前验并不顺利,因此需要加步骤2.5等,见下表;**

| 31018 | 插入一步: 步骤2.5 |
| --- | --- |
| 步骤2.5 | 饿了更饿: 认知模式(`饿(持续饿感3次)`x20轮); =>存为FZ902.5 |
| 实践 | 加了步骤2.5后,对后面步骤的训练都有影响,所以需要重整理下所有步骤并重新训练下: **↓↓↓** |
| 回测 | 按如下8个步骤回测下 (只需要训练2.5之后的步骤,之前的不变可复用FZ871和FZ882); |
| 步骤1 | 带皮学饿: 认知模式(`饿(持续饿感3次),扔随机带皮坚果,不吃,又饿`x200轮); =>存为FZ871 |
| 步骤2 | 学认木棒: 认知模式(`随机路边出生,扔木棒` x 300轮); =>存为FZ882 |
| 步骤2.5 | 饿了更饿: 认知模式(`饿(持续饿感3次)`x20轮); =>存为FZ902.5 |
|  | > 重点日志: 看下点了饿后,立马能识别到`[饿]->{更饿}`; |
| 步骤3 | 带皮学吃: 认知模式(`饿,路边出生,路上就近扔带皮果,扔棒去皮,手动飞过去,触发吃掉`)x近中远上下各1次 =>存为FZ903 |
|  | > 重点日志: 看下`newRCanset`日志,应该能生成许多(避免更饿)RCanset; |
| 步骤4 | 学H去皮: 动物模式(`随机路边出生,饿,扔随机带皮果,扔木棒`x70轮); =>存为FZ904 |
|  | > 重点日志: 看下`newHCanset`日志,应该能生成许多(去皮)HCanset; |
|  | 问题1. 在加入步骤2.5后,步骤4学不到去皮的HCanset了,需要再跑跑分析下原因; |
|  | 分析1. 看起来是步骤3得到的newRCanset太具象了,很难走到`无皮果HDemand`那一帧; |
|  | 解答1. 可以先跑跑后面的`预想与实际类比`和`过渡到交层`,然后再来跑第4步看下能不能得到newHCanset; |
|  | 实践1. 把步骤4(学H去皮)调整到步骤6(过渡到交层Canset)之后 `转3101a`; |
| 步骤5-8 | 本表只训练到步骤4....步骤5到步骤8因以上`步骤4-问题1`导致本表未继续训练,略; |
| 结果1 | 本表补了个步骤2.5,然后整个后面的都要重新训练,有点太麻烦 `太麻烦的问题 转31019`; |
| 结果2 | 本表测得步骤4(学H去皮)训练未得到`去皮newHCanset`的问题 `转3101a`; |

| 31019 | 最近总是发现训练步骤会缺一些东西,导致推进不顺 |
| --- | --- |
| 分析 | 比如上面的步骤2.5就是缺了饿了更饿,而31017-问题4又测得了饿了更饿没rCanset; |
| 重点 | 如果每次缺了什么,就补一个步骤,再重新训练,补一点点就重新跑一次训练,那得累死; |
| 方案 | 先废除训练步骤,边跑边测边推进,缺什么就训练什么,灵活点搞; |
|  | 优点: 这么做的优点是,灵活训练,缺什么训练什么,更容易发现问题,推进测试和修补系统细节问题; |
| 结果 | 先采用本表方案,**等灵活跑顺了,再改回:规划训练步骤;** `T` |
| 追加 | `灵活跑`的方案,还是灵活用吧,想用时用用,但主要还是以规划步骤为主线 `T`; |

**小结: 31018训练了: 饿了更饿,但发现"学H去皮"不顺利,转下表把学H去皮后置一些;**

| 3101a | 将步骤4后调到步骤6之后 |
| --- | --- |
| 说明 | 本表在31018的基础上,将31018-步骤4,调整到步骤6之后 (因为在RCanset更抽象后,); |
| 解析 | 本表: 步骤1-3是基础训练,4-6是rCanset训练,7-8是搬运带皮果训练,9之后是去皮训练; |
| 步骤1 | 带皮学饿: 认知模式(`饿(持续饿感3次),扔随机带皮坚果,不吃,又饿`x200轮); =>存为FZ871 |
| 步骤2 | 学认木棒: 认知模式(`随机路边出生,扔木棒` x 300轮); =>存为FZ882 |
| 步骤3 | 饿了更饿: 认知模式(`饿(持续饿感3次)`x20轮); =>存为FZ913 |
|  | > 重点日志: 看下点了饿后,立马能识别到`[饿]->{更饿}`; |
| 步骤4 | 带皮学吃: 认知模式(`饿,路边出生,路上就近扔带皮果,扔棒去皮,手动飞过去,触发吃掉`)x近中远上下各1次 =>存为FZ914 |
|  | > 重点日志: 看下`newRCanset`日志,应该能生成许多(避免更饿)RCanset; |
| 步骤5 | 预想与实际类比: 动物模式(`与带皮学吃一致`)x近中远上下各1次 (参考30154-测1) =>存为FZ915 |
|  | > 重点日志: 看下`预想与实际`日志,应该能类比生成许多抽象RCanset; |
| 步骤6 | 过渡到交层Canset: 动物模式(路边出生,饿,就近Y大致对齐路中扔皮果,扔棒,手动飞至,触发吃掉)x上下各3次 =>存为FZ916 |
|  | > 说明: 之所以要Y大致对齐,是为了让鸟和果的相对位置相对稳定,这样能帮助从似层快速过渡到交层; |
|  | > 重点日志: 看下`预想与实际`日志,应该能类比生成许多`交层Canset` (参考31014-方案&第5行日志); |
| 步骤7 | 搬运动机: 动物模式(`随机路边出生,饿,扔随机带皮果,扔木棒`x70轮) =>存为FZ917; |
|  | > 重点日志: 看下`OR反省`日志,rCanset的SP有增强 **(SP的增强就等价于搬运动机)**; |
|  | > 说明1: 搬运动机其实就是激活了`路中带皮果`,然后转成HDemand,来加工带皮果从路边到路中 `参考31011-原则&测下`; |
|  | > 说明2: 激活SP最稳定的Canset `如:[饿,路中带皮果,棒,无皮果,飞,吃]`,而第2帧带皮果不在路上就转为H任务搬运 `转下步`; |
| 步骤8 | 搬运训练: 动物模式(路下出生,路下扔带皮果,路上带皮果转为h任务后,把坚果搬运到路上,扔木棒,飞,吃) |
| 步骤9 | 学H去皮: 动物模式(`随机路边出生,饿,扔随机带皮果,扔木棒`x70轮) =>存为FZ919 |
|  | > 重点日志: 看下`newHCanset`日志,应该能生成许多(去皮)HCanset; |
|  | > 说明: 其实学H去皮不需要特意训练,只要有了"路中带皮果",无非就是看到木棒后,自然就有了"无皮果"; |

**小结: 本表在上面几张表:新增了"饿了更饿"和"学H去皮"后置后,重新整理了一下9个步骤;**

| 3101b | 上表步骤7训练后,发现OR反省中SP值普遍<3 |
| --- | --- |
| 简介 | 因为SP的增强就等价于搬运动机,所以能解决饥饿问题的正确rCanset能够增强SP稳定性非常重要; |
| 分析 | 1. 只有步骤4到6顺利吃到了,但次数很少,而步骤7中的70次经历都是没吃到的; |
|  | 2. 即步骤4到6的rCanset一次次激活又失败,它们的SP稳定性都已经很低; |
|  | 3. 此时TCTransfer迁移到新场景上的rCanset会不会继承那个很低的SP呢? |
|  | 4. 如果不会继承SP值,就可能导致本表的问题,即迁移过来的SP默认为S0P0,但稳定性却大于那些很低的rCanset; |
| 线索 | 5. 从而导致总是比较新迁移出来的rCanset被最终激活,它的SP值也必然是<3的(因为没继承迁移前的SP值); |
| 方案 | 在TCTransfer迁移出新canset时,可以继承(/推举)一下SP值; |
| todo1 | 继承算法加上随便继承SP值 `T`; |
| todo2 | 推举算法也加上SP推举初始值 (参考下方方案2及相关分析) `T`; |
|  | 方案1. 暂不加推举SP值 `5%` |
|  | >>> 推举时也推举SP值吧 (比如吃了苹果和梨了,会认为水果大几率能吃); |
|  | 方案2. 谁推举就加谁的SP初始值 `95%` |
|  | >>> 防重复推举: 推举的canset可能本来就有,已推举过的不重复推举; |
|  | >>> 推举SP机制: 推举一次更新一次SP,即谁新推举时,计入它的SP即可,这样其实与方案3是等效的; |
|  | 方案3. 从多个具象里综合sumSP值 `5%` |
|  | >>> 方案3求综合sumSP值有点废性能不可取; |
|  | 结果: 根据以上分析,选择方案2进行实践 `T`; |
| todo3 | 推举或继承都要防重 (参考todo2-方案2-防重复) `本就支持 T`; |
| todo4 | 推举和继承SP值的机制都是异步做,谁推举/继承,谁的SP值就计进去 (参考todo2-方案2-推举SP机制) `T`; |
| todo5 | 构建cansetFo时,改为场景内防重,而不是全局防重 (为什么这么做的原因如下) `T`; |
|  | 为什么这么做: 如果全局防重,在各场景生成一模一样的cansetFo时,分别继承SP,会混在一起,SP全累计到一起; |
|  | 比如1: 在家吃饭的SPEFF感觉,和在野外独自一人吃饭肯定不一样,虽然都是吃饭,但场景不同,不应该混在一起; |
|  | 比如2: 在北京吃龙虾不行,在家是可以的 (这些canset虽然内容一样,但SPEFF完全不同,不能窜); |
| todo6 | 同理todo5:在预想与实际类比构建absCanset时 和 自然未发生时创建canset,也都改为场景内防重 `T`; |
| 结果 | 改完后,再跑FZ917,看OR反省日志,有了SP值>6的情况了,虽然不是很多; |

**小结: 本表写了: 1.迁移时连带SP值 2.构建Canset改为场景内防重**

**总结: 本节跑搬运动机,并修复了一些细节问题,不过搬运动机依然还不是很顺,`FZ917,饿,路边有皮果,棒`,这个过程中生成的hDemand往往是针对木棒(这种情况占90%以上),而不是针对带皮果(占比2%左右),但日志太杂而乱了,日志几乎是不可读状态,TO执行的循环太多次类似的在跑,转下节先把这个TO循环太杂乱的问题搞搞再说;**

***

## n31p02 TO类似任务执行太多次问题: 同质Root合并
`CreateTime 2023.12.11`

见上节末总结,TO循环太杂乱了,全是类似的Demand在反反复复的跑;

| 31021 | TO循环虽然与TI分离了,但针对类似任务还是执行太多次了 |
| --- | --- |
| 说明 | 比如感到饿,然后看到带皮果,然后看到木棒,这个过程中,触发多次识别,然后触发Demand,触发TO |
| 分析 | 能不能把这种非常类似的任务都整合一下,避免反反复复的TO过程,又耗能,又没啥用,还看起来混乱; |
| 方案v1 | 看下类似的Demand在有新帧输入时,全更新到原类似RootDemand中,而不是生成为新的RootDemand `5%`; |
| 问题 | 分析root防重的判定方法: 即怎么判定各个pFo是属于"类似"的,如以下两个时序: |
|  | 比如: 先识别到:`F1[A1,B1,C1],cutIndex=B1`; 过了一会又识别到:`F2[A2,B2,C2],cutIndex=C2`; |
|  | 疑问: F1和F2是"类似"时序吗?如果A1和A2的mcIsBrother成立,或者mIsC成立,那么算"类似帧"吗? |
|  | 解答: **可以以A1和A2都在同一个概念识别的matchAlgs结果中,来判断它们是"类似的"**; |
|  | 实践规划: 在DemandManager生成Root时,判断pFo,将所有"类似"的pFo都归到同一个rootDemand下; |
| 举例 | 说白了,如果你饿了,你在做饭中,又感受到了饿,你需要重新决策还是继续做饭? |
|  | 说明: 这确实是两次饿,但它们相似度高,且第1次饿正在推进中 (本例迎来转机,从而让本表转向方案v2); |
|  | 调试: 通过实际调试分析生成任务的情况: 见31021代码段,确实会有数次饥饿任务,并且没有前后衔接上,导致重复决策; |
| 方案v2 | 在DemandManager生成RDemand时,看下如果有同质的,就直接把pFo下的枝叶solution推进进度移过来 `95%`; |
|  | 说明: 新任务把旧同质任务的solution枝叶继承过来; |
|  | 实践问题: 下一帧如果和上一帧+1一致时,将上一帧+1的工作记忆成果移过来继续用 (那么怎么判断一致呢?); |
|  | 解答: 只要旧帧和新帧的pFo是同一个matchFo; |
|  | >>> 1. 那么新帧的输入肯定对的上旧帧预测的那一帧 (即肯定这一帧一致); |
|  | >>> 2. 且其下的工作记忆成果都可以兼容移过来 (因为本来就是同一个matchFo,当然可以移植); |
|  | 实践规划: 在DemandManager生成Root时,判断pFo,将旧有"类似"的pFo的subSolution直接挂到新的pFo下; |
| 抉择 | 方案v1是在空想情况下得出的方案,而方案v2是在实际调试训练跑日志后得出的方案,所以选业方案v2 `实践转31022`; |

```c
31021-代码段A: 通过两种训练(手训和自训各跑一次),看下日志,都生成了哪些Root任务;
//第1种尝试. 手训步骤,看下solution过度执行的问题;
//复现: FZ917x2,路边出生,饿,路中扔带皮果,棒
//日志: 测得以下日志,TO确实一直在执行,每次不是果饿果饿,就是饿果饿果;
//分析: 此时看起来已经是去皮成功了,只差飞过去吃掉;
//尝试: 可以试下feedbackTIP是不是也要收集往后送 / 或者pInput时,也要调用feedbackTIR吧,因为现在mv也会入时序中;
//说明: 如下在训练中共7次生成RDemand;
RMV新需求: 饿 (条数+1=1 评分:-10.226748)
	 pFo:F3566[M1{↑饿-16}]->{-10.27} SP:{0 = S0P559;1 = S358P200;} indexDic:{0 = 0;}
	 //另外有类似F3566的别的pFo: F3521 F3579 F3871 F3543 F3597 F3717 F3825 F3900 F3611 F3531 F3553 F3629 F3651 F3908 F3699

RMV新需求: 饿 (条数+1=1 评分:-10.226748)
	 pFo:F3566[M1{↑饿-16}]->{-10.27} SP:{0 = S0P559;1 = S358P200;} indexDic:{0 = 0;}
   //另外有类似F3566的别的pFo: F3521 F3579 F3871 F3543 F3597 F3717 F3825 F3900 F3611 F3531 F3553 F3629 F3651 F3908 F3699

RMV新需求: 饿 (条数+1=3 评分:-10.226748)
	 pFo:F3566[M1{↑饿-16}]->{-10.27} SP:{0 = S0P560;1 = S359P200;} indexDic:{0 = 3;}
   //另外有类似F3566的别的pFo: F3521 F3579 F3871 F3543 F3597 F3717 F3825 F3900 F3611 F3531 F3553 F3629 F3651 F3908 F3699

RMV新需求: 饿 (条数+1=4 评分:-14.4)
   pFo:F6355[A6339(向191,距122,果),M1{↑饿-16},A6347(向191,距126,棒),A6339(向191,距122,果)]->{-14.40} SP:{0 = S0P10;3 = S0P10;2 = S0P10;1 = S0P10;4 = S9P1;} indexDic:{0 = 0;3 = 3;2 = 2;1 = 1;}

RMV新需求: 饿 (条数+1=5 评分:-9.751501)
	 pFo:F3566[M1{↑饿-16}]->{-10.28} SP:{0 = S0P561;1 = S360P200;} indexDic:{0 = 3;}
   //另外有类似F3566的别的pFo: F3521 F3579 F3871 F3543 F3597 F3717 F3825 F3900 F3611 F3531 F3553 F3629 F3651 F3908 F3699
   //以及以下几个不类似的4个pFo >>> 内容为[饿,饿]->{饿}:F3534 F3546 F3559 F3524

RMV新需求: 饿 (条数+1=6 评分:-9.759939)
	 pFo:F3566[M1{↑饿-16}]->{-10.29} SP:{0 = S0P562;1 = S361P200;} indexDic:{0 = 3;}
   //另外有类似F3566的别的pFo: F3521 F3579 F3871 F3579 F3543 F3597 F3717 F3825 F3900 F3611 F3531 F3553 F3629 F3651 F3908 F3699
   //以及以下几个不类似的4个pFo >>> 内容为[饿,饿]->{饿}:F3534 F3546 F3559 F3524

RMV新需求: 饿 (条数+1=7 评分:-8)
	 pFo:F16518[A8905(距122,果),A13(饿16,7),A8905(距122,果)]->{-8.00} SP:{0 = S0P12;1 = S0P12;2 = S0P12;} indexDic:{0 = 1;1 = 2;2 = 3;}

//第2种尝试. 再试下训练自训步骤: "学H去皮",看下日志关于过度执行solution的问题;
//复现: "FZ917,学H去皮";
//  a. 发现训练一轮间,确实数次饿感和看到木棒,坚果,是数次分别形成了pFos;
//  b. 且在形成HDemand(木棒)前木棒视觉已经发生完毕了,导致它压根反馈不到;
//  c. 除非两次pFos之间,可以过度一下...
//  d. 从以下日志可见,在同一轮训练中: 数次生成rDemand,非常类似;
//说明: 如下在训练中共6次生成Demand;

第1次: RMV新需求: 饿 (条数+1=1 评分:-10.252431)
 pFo:F3566[M1{↑饿-16}]->{-10.29} SP:{0 = S0P568;1 = S364P202;} indexDic:{0 = 0;}
 //另外有类似F3566的别的pFo: F3521 F3579 F3871 F3579 F3543 F3597 F3717 F3825 F3900 F3611 F3531 F3553 F3629 F3651 F3908 F3699

第2次: RMV新需求: 饿 (条数+1=2 评分:-16)
 //四条pFo: [饿,皮果]->{饿} 分别为:F2096 F2031 F1700 F1980

第3次: RMV新需求: 饿 (条数+1=3 评分:-9.755568)
 pFo:F3566[M1{↑饿-16}]->{-10.27} SP:{0 = S0P569;1 = S365P203;} indexDic:{0 = 3;}
 //另外有类似F3566的别的pFo: F3871 F3521 F3579 F3543 F3597 F3717 F3825 F3900 F3611 F3531 F3553 F3629 F3651 F3908 F3699
 //以及以下几个不类似的4个pFo >>> 内容为[饿,饿]->{饿}:F3534 F3546 F3559 F3524

第4次: RMV新需求: 饿 (条数+1=4 评分:-16)
 //四条pFo: [饿,皮果]->{饿} 分别为:F2096 F2031 F2315 F1700

第5次 =============================== 32 hDemand ===============================
 A4249(向351,距150,棒)
 TO上轮:成功 等待:0.0 下轮:5 消息:out 此帧需要HDemand来完成,已转为h任务
 第1条 饿 评分-16.00 激活成功     {proto:F15687 pFos:(F2096,F2031,F2315,F1700)}

第6次: RMV新需求: 饿 (条数+1=5 评分:-10.244307)
 pFo:F3566[M1{↑饿-16}]->{-10.28} SP:{0 = S0P570;1 = S366P203;} indexDic:{0 = 3;}
 //另外有类似F3566的别的pFo: F3521 F3871 F3579 F3543 F3597 F3717 F3825 F3900 F3611 F3531 F3553 F3629 F3651 F3908 F3699

**结果: 如上两种训练方式,都数次生成很类似的Demand,是非常应该想办法防止重复决策的,转31021-举例-调试**
```

**小结: 以上针对同质任务重复太多次执行的问题: 制定方案 & 并代码日志前验分析了下很有(rootDemand防重合并的)必要性;**

| 31022 | 同质任务重复太多次执行问题-实践前问题: 为什么要合并?并到什么程度? |
| --- | --- |
| 说明 | 本表分析rootDemand并的必要性有多大?怎么并?并介入实例细节分析下,并到什么程度; |
| 内存角度 | 1. 即使并成一帧,也只是outModels并了,能省不少内存 (但目前这个动不动模拟重启的训练,省内存也没啥用); |
|  | 2. 而inModels依然是四帧没变,也没啥用; |
|  | 总结: 所以在内存角度看,合并没意义; |
| 举例分析 | 通过举例分析,到底该不该并? |
|  | 比如: 张三会先后扔出x个飞标打我,最好的方法就是接住所有x个飞标,并扔回去将张三biu死; |
|  | 分析: 此例中,张三和飞标都会带来危险,先分析下此例,共带来多少细节危险任务,这些是否都需要合并; |
|  | >>> 1. 某个飞标的位置一直在变,会不断更新新的[matchFo]->{危险} `本来就是同一飞标变了位置,可合并`; |
|  | >>> 2. 也会有新的飞标被扔出,即新加入新的飞标[newMatchFo]->{危险} `合并到新帧可方便统筹分析一并接住所有飞标`; |
|  | >>> 3. 张三的位置不变,可能除第一眼外压根不看张三[首帧张三]->{危险} `合并到新帧才能实现:接住后直接扔回的canset` |
|  | 结果: 根据上例中三种情况分析,是**都应该合并的,即只要新旧pFos有交集,则直接把新旧pFos全合并到新帧RootDemand里**; |
| 总结 | 从`内存角度`未分析到全面合并的必要性,但从`举例分析`分析到应该尽量合并,以使之方便`统筹求解`; |

**小结: 以上通过介入实例分析(rootDemand防重合并)的必要性,其中三个情况的分析,为后面代码实践指明了方向;**

| 31023 | 同质任务重复太多次执行问题-实践前问题: 具体怎么并? |
| --- | --- |
| 说明 | 本表分析怎么合并: 是把旧pFo的枝叶移到新的下面?还是是直接旧的替新的?还是两帧全保留? |
| 顺便 | 本表顺便分析下旧的solution移给新Root时,是不是有cutIndex等需要兼容下,或者避免产生兼容问题; |
| 方案1 | 旧枝叶+新壳子: 把旧的枝叶嫁接给新的pFo,旧的pFo壳子删掉; |
| 方案2 | 旧枝叶+旧壳子: 仅保留旧的pFo及其枝叶,新的pFo删掉; |
| 方案3 | 旧全部+新全部: 旧的枝叶和壳子全保留,新的pFo也保留; |
| 分析 | 目前倾向于第3方案,把两个都留下: |
|  | 原因1. 反证据: 因为cutIndex不同,取canset候选集其实是会不一样的,旧的枝叶canset未必就是新scene壳子的方案; |
|  | 原因2. 反证据: 因为cutIndex不同,本来新壳子+旧枝叶就会有兼容性问题 (比如判断条件满足等,壳子和枝叶都是严密贴合的); |
|  | 原因3. 正证据: 二者同时存在并不冲突,各取各的候选方案,公平竞争即可 (比如冷水和烧至温水,二者都可继续烧变成开水); |
| 结果 | 因以上分析3个原因先选定方案3 `转31024进行代码实践 T`; |

**小结: 以上分析具体合并后,新旧同质的pFo保留哪一个 (决定新旧pFos二者全留,旧root删掉),为后面代码实践明确了该怎么做;**

| 31024 | 同质任务重复太多次执行问题-实践规划 |
| --- | --- |
| todo1 | 判断新旧Root的pFo有交集,则直接移植旧pFos(壳子和枝叶)到新的Root的pFos中(即二者合并,参考31023-方案3) `T` |
| todo2 | 合并后,把旧的Root直接删掉 (合并后,旧的没了,只留新的) `T`; |
|  | 1. 即推进一帧后,上一帧的root可以直接关闭 (即移植是移动,而非复制); |
|  | 2. 但上一帧也不是完全无用,有些正在推进中的canset是可以继续搞的 (即移植后,它所在的pFo继续推进它); |

***

## n31p02b TO第2步转为候选集巨慢优化
`CreateTime 2023.12.21`

回测上节Root合并,并且测得TO第2步转为候选集巨慢,在本节优化一下;

| 31025 | 回测 |
| --- | --- |
| 回测1 | 手动步骤(参考3101a-步骤6)回测: `FZ917x2,饿,路边出生,路上就近扔带皮果,扔棒去皮` |
|  | 目的: 这么训练的目的是为了看下TO还会不会同质重复执行太多次; |
|  | 效果: TO执行几次后,小鸟会自行飞过去,触发吃掉,连续试了三次,都是如此,其中三次飞成功后,OR反省的日志如下: |
|  | spIndex:4 -> (好) null->S0P1 F18814[M1{↑饿-16},A8905(距122,果),A13(饿16,7),A8905(距122,果),飞↑,果,吃] |
|  | spIndex:4 -> (好) S0P1->S0P2 F18814[M1{↑饿-16},A8905(距122,果),A13(饿16,7),A8905(距122,果),飞↑,果,吃] |
|  | spIndex:4 -> (好) S0P2->S0P3 F18814[M1{↑饿-16},A8905(距122,果),A13(饿16,7),A8905(距122,果),飞↑,果,吃] |
|  | 结果: 目前看起来,确实没有大量同质Root重复执行 (毕竟已经合并了),但还需要再跑跑别的训练试试 (转回测2); |
| 回测2 | 自动步骤(参考3101a-步骤7)回测: `随机路边出生,饿,扔随机带皮果,扔木棒` |
|  | 目的: 持续饿感会持续三次,看下这三次有没合并同质Root,看下同质Root会不会重复执行太多; |
|  | 问题: 见31025-代码段日志,从日志可解读出两个问题: |

```java
31025-代码段
195 [23:19:30:848 TO        TCSolution.m  39] =============================== 2 rSolution ===============================
196 [23:19:30:848 TO        TCSolution.m  39] 任务源:饿 protoFo:F19095[M1{↑饿-16}] 已有方案数:0 任务分:-10.30
198 [23:19:31:430 TO           TCScene.m  84] 第1步 R场景树枝点数 I:16 + Father:16 + Brother:304 = 总:336
1454 [23:19:45:862 TO    TCSolutionUtil.m 216] 第2步 转为候选集 总数:652
1455 [23:19:45:863 TO    TCSolutionUtil.m 237] 第5步 Anaylst匹配成功:652
1456 [23:19:45:866 TO    TCSolutionUtil.m 243] 第6步 排除不应期:652
1457 [23:19:45:888 TO    TCSolutionUtil.m 249] 第7步 排除FRSTime来不及的:0
1458 [23:19:45:889 TO        TCSolution.m 166] >>>>>> rSolution 无计可施
//问题1. 从第1步到第2步转为候选集,跑了15秒,这15秒够死多少回了,查并优化;
//  > 可见现在转候选集是很耗能的 -> 下面主要边调试性能边优化第1步到第2步的性能,如下:
//  > todo1. 优化AIFilter.solutionCansetFilter()候选集过滤器中的排序 (优化了7秒左右 -> 效果:优化至8s内);
//  > todo2. 优化solutionFoRankingV3()候选集排序 (优化了1秒左右 -> 效果:优化至7s内);
//  > todo3. 优化rSolution_Slow()提前在for之前取scene所在的pFo,以优化其性能 (优化了0.x秒);
//  > todo4. 优化TCScene取的场景树防重 (优化了5秒左右 -> 效果:优化至1s内);
//  > 总结: todo1和2是提前取AIEffectStrong模型,减少执行数,todo4是场景防重,减少它带来的执行数,最终优化至1s内,顺利完成 `T`;
//  > 回测: 回测日志如下:
4497 [09:18:20:179 TO           TCScene.m 108] 第1步 R场景树枝点数 I:16 + Father:1 + Brother:9 = 总:26
4498 [09:18:20:470 TO    TCSolutionUtil.m 228] 第2步 转为候选集 总数:202
10948 [09:19:27:051 TO           TCScene.m 108] 第1步 R场景树枝点数 I:20 + Father:2 + Brother:8 = 总:30
10950 [09:19:27:378 TO    TCSolutionUtil.m 228] 第2步 转为候选集 总数:201
//问题2. 第7步,652条候选集,全部都是来不及?
//  > 查下能不能提前对FRSTime来不及做评价,而不必在转为候选集后 (或者提前到一个不影响性能的阶段);
//  > 经查FRSTime中取到validPFos为空,因为全是isExpired失效状态,所以判断giveTime全是0,怎么都来不及;
//  > 思路,跑下31025-回测2,并把isExpired过期的日志打出来,查下为什么全失效了:
//  > 日志1. 196 [23:25:04:115 TO           TCScene.m  84] 第1步 R场景树枝点数 I:16 + Father:16 + Brother:304 = 总:336
//  > 日志2. 1426 [23:25:18:153 TO    TCSolutionUtil.m 216] 第2步 转为候选集 总数:809
//  > 说明: 如上日志: 因为solution太慢,02秒时构建任务,10秒时已经全过期了,到18秒才转为候选集完成,当然后面全是失效,FPSTime失败;
//  >   过期原因1. feedbackTIP在8秒后发生,会导致过期 (上面就是因为这个过期的);
//  >   过期原因2. 触发器本身到期也会过期 (触发器是10s左右,上面不是因为这个,但也等不到18秒);
//  > 举例: 说白话,就是你三秒内必须躲开,你决策这个问题就用了10秒,等你想到办法了,早就黄花菜都凉了;
//  > 解答: 还是得解决下问题1,卡顿问题,只要卡顿解决了,自然就不会来不及了 `问题1修复后,此问题好了,日志如下:`;
193 [08:53:54:521 TO        TCSolution.m  39] =============================== 2 rSolution ===============================
194 [08:53:54:521 TO        TCSolution.m  39] 任务源:饿 protoFo:F24563[M1{↑饿-16}] 已有方案数:0 任务分:-10.30
196 [08:53:55:142 TO           TCScene.m 108] 第1步 R场景树枝点数 I:16 + Father:1 + Brother:9 = 总:26
208 [08:53:56:570 TO    TCSolutionUtil.m 228] 第2步 转为候选集 总数:203
209 [08:53:56:570 TO    TCSolutionUtil.m 251] 第5步 Anaylst匹配成功:203
214 [08:53:56:571 TO    TCSolutionUtil.m 257] 第6步 排除不应期:203
225 [08:53:56:590 TO    TCSolutionUtil.m 263] 第7步 排除FRSTime来不及的:203
```

**小结: 31025优化了TO性能(从15s优化到1s),然后回测31024同质任务执行太多的问题没啥问题了,手动和自动步骤都没发现明显问题;**

***

## n31p02c 学会搬运
`CreateTime 2023.12.28`

上节TO性能ok了,本节正式开始搞下搬运训练;

| 31026 | 正式开始做: 步骤8-搬运训练 |
| --- | --- |
| 示图1 | ![](assets/711_搬运动机示图.png) |
| 示图2 | ![](assets/712_搬运动机示图2.png) |
| 第1步 | 试下能必现搬运动机 |
|  | 步骤规划: `路下远些出生,饿,路下近些扔坚果,扔木棒` (见示图1); |
|  | 日志分析: 日志分析见31026-代码段1; |
|  | 结果: 虽然有一些小问题,但搬运动机是存在的 (只要生成了带皮果H任务,就说明动机ok); |
| 第2步 | 再做下搬运看能够学到搬运hCanset |
|  | 步骤规划: `路下出生,饿,鸟同位置扔带皮果,把坚果踢到路上` (见示图2); |
|  | 重点关注1: 看下踢了带皮果后,有没有反馈到hDemand带皮果; |
|  | >>> 参考31026-代码段2-feedbackTOR部分,日志可见反馈带皮果顺利; |
|  | 重点关注2: 看下在反馈到hDemand带皮果后,有没有生成新的hCanset; |
|  | >>> 参考31026-代码段2-OR反省部分,日志可见可顺利生成新hCanset; |
|  | 结果: 关注1和关注2都实训顺利 `接下来可以正式训练下第8步,转31027`; |

* 31026-代码段1: 31026-第1步跑出日志如下:

```c
=============================== 11 hSolution ===============================
目标:A4614(向267,距11,皮果) 已有S数:0
第1步 H场景树枝点数 I:1 + Father:0 + Brother:0 = 总:1
第2步 转为候选集 总数:0
第5步 Anaylst匹配成功:0
第6步 排除不应期:0
第7步 排除FRSTime来不及的:0
>>>>>> hSolution 无计可施

=============================== 82 hSolution ===============================
目标:A4015(向91,距10,皮果) 已有S数:0
第1步 H场景树枝点数 I:1 + Father:0 + Brother:0 = 总:1
第2步 转为候选集 总数:0
第5步 Anaylst匹配成功:0
第6步 排除不应期:0
第7步 排除FRSTime来不及的:0
>>>>>> hSolution 无计可施
```
* 问题. 共执行hSolution31次,只有两次是皮果H任务,别的全是木棒H任务 (而生成任务共50次,皮果占18次,木棒占32次);
  - 说明. 皮果H任务占36%,但执行hSolution却只占6.5%;
* 暂停: 这问题先不管了,只要能生成H任务就是有动机,至于占比太少的问题,随后看影响很重要,到时再查 `暂停解决此问题 T`;

```c
31026-代码段2:
说明: 此处仅有日志,具体的问题和解答,在31026-第2步: 重点关注1和关注2;
=============================== 2 rSolution ===============================
任务源:饿 protoFo:F27751[M1{↑饿-16}] 已有方案数:0 任务分:-10.34
第1步 R场景树枝点数 I:16 + Father:1 + Brother:9 = 总:26
第2步 转为候选集 总数:176
第5步 Anaylst匹配成功:176
第6步 排除不应期:176
第7步 排除FRSTime来不及的:176
0. I<F3597 F4659[M1{↑饿-16},A4614(向267,距11,皮果),A4618(向342,距82,棒),A4623(距24,向272,棒),A4624(向267,距11,果),飞↓,A4633(距33,向211,棒),A4634(向260,距0,果),A4639(向205,距34,棒),A3981(吃1)]> {1 = S1P1;}:(分:0.50) H1N0:(分:1.00)
1. I<F3597 F4728[M1{↑饿-16},A4683(向275,距13,皮果),A3106(向350,距143,棒),A4695(距25,向275,棒),A4696(向275,距13,果),飞↓,A4705(距52,向200,棒),A4706(向283,距5,果),A4711(向197,距54,棒),A3981(吃1)]> {}:(分:0.50) H1N0:(分:1.00)
=============================== 2 行为化Fo ===============================
第 2/10 个,时序:F4659[M1{↑饿-16},A4614(向267,距11,皮果),A4618(向342,距82,棒),A4623(距24,向272,棒),A4624(向267,距11,果),飞↓,A4633(距33,向211,棒),A4634(向260,距0,果),A4639(向205,距34,棒),A3981(吃1)]
=============================== 2 行为化前 反思评价 ===============================
> 最严重子任务分(饿):-9.57 > 当前任务分(饿):-10.34 =====> 已通过
_Fo行为化第 2/10 个: F4659[M1{↑饿-16},A4614(向267,距11,皮果),A4618(向342,距82,棒),A4623(距24,向272,棒),A4624(向267,距11,果),飞↓,A4633(距33,向211,棒),A4634(向260,距0,果),A4639(向205,距34,棒),A3981(吃1)]
---//构建行为化帧触发器:0x6000038cc0f0 for:饿 time:2.11
=============================== 3 hDemand ===============================
A4614(向267,距11,皮果)
=============================== 3 feedbackTOR ===============================
输入ProtoA:A27753(距0,向229,皮果) (识别matchAlgs数:30)
等待中任务数:5
RCansetA有效:M(A27753) C(A4614) 结果:1
=============================== 9 OR反省 ===============================
spIndex:1 -> (好) S1P1->S1P2 F4659[M1{↑饿-16},A4614(向267,距11,皮果),A4618(向342,距82,棒),A4623(距24,向272,棒),A4624(向267,距11,果),飞↓,A4633(距33,向211,棒),A4634(向260,距0,果),A4639(向205,距34,棒),A3981(吃1)]
因OR反省(好 第2帧)为rCanset:F4659 -> A27753(距0,向229,皮果) 挂载NewHCanset:
F27769[M1{↑饿-16},A27753(距0,向229,皮果),踢↑,A27760(距8,向96,皮果)]
---//行为化帧触发理性反省:0x6000038cc0f0 A4614 状态:OuterBack
```

| 31027 | 进行搬运训练并存为FZ918 |
| --- | --- |
| 步骤8 | 搬运训练: 动物模式(路下出生,饿,鸟同位置扔带皮果,把坚果踢到路上) `存为FZ918` |
|  | > 重点日志: 搜hCanset,应该有为有皮果生成新的hCanset,即踢↑之后得到路上的有皮果; |
|  | > 说明: 训练步骤`参考31026-示图2`,重点日志`参考31026-代码段2-OR反省`; |
| 结果 | 已学会搬运并存为FZ918 `使用搬运转下节 T`; |

**小结: 本节测搬运动机和学搬运都顺利,并最终正式训练后,存为FZ918;**

***

## n31p05 运用搬运
`CreateTime 2024.01.01`

本节运用搬运;

| 31050 | 测下使用搬运hCanset |
| --- | --- |
| 重点 | **主要测搬运hCanset的迁移性,看在类似情况时,能够自主搬运坚果到路上** |
| 训练 | 跑下`FZ918,路下出生,饿,鸟同位置扔带皮果`,看他能不能自行搬运到路上; |
| 结果 | 测得31051的问题; |

| 31051 | 生成有皮果H任务,却未能执行hSolution问题 |
| --- | --- |
| 问题 | 如下`31051-代码段1`可见,虽然生成了hDemand,但却没继续推进hSolution,而是执行了另一个rRoot; |
| 回顾 | `2023.12.29的31026-代码段1左右`已经遇到过这个问题,只是没重视,看来躲不过了,本表查修下; |
| 原因 | 经调试,因为两个Root竞争,虽然先来的生成的hDemand,但后来的更迫切 `参考31051-代码段2`; |
| 方案1 | Root看能不能再合并 (都是饿,可以试下从时序识别切入,因为饿了更饿在看到皮果后,也全含,应该也能识别到); |
|  | 缺点: 看起来此方案可以解决这个问题,但是一种妥协下的小聪明,会导致别的问题,比如: 被烧和被咬都是疼,但不应合并; |
| 方案2 | 已经有一些推进的Root应该加权,其实就是为了任务更持续防止被经常性打断的设计 (参考沉没成本) `95%`; |
|  | 白话说明: 其实就是为了: 避免徒劳,已经付出努力的价值,计为进度分; |
|  | 代码说明: 就是把solutionFo的推进计算成progressScore加到demandScore里,影响ROOT的排序; |
| 结果 | 暂选定方案2,转31052进行实践分析; |

```c
31051-代码段1:
=============================== 1 rDemand ===============================
RMV新需求: 饿 (第1条 评分:-10.471538)
	 pFo:F3566[M1{↑饿-16}]->{-10.50} SP:{0 = S0P587;1 = S384P201;} indexDic:{0 = 0;}
	 pFo:F3871[M1{↑饿-16}]->{-10.50} SP:{0 = S0P546;1 = S357P187;} indexDic:{0 = 0;}
	 pFo:F3825[M1{↑饿-16}]->{-10.49} SP:{0 = S0P547;1 = S358P188;} indexDic:{0 = 0;}

=============================== 2 概念识别 ===============================
A15171(距0,向62,皮果)

=============================== 2 rSolution ===============================
任务源:饿 protoFo:F15169[M1{↑饿-16}] 已有方案数:0 任务分:-10.47
第1步 R场景树枝点数 I:16 + Father:1 + Brother:9 = 总:26
第2步 转为候选集 总数:192
第5步 Anaylst匹配成功:192
第6步 排除不应期:192
第7步 排除FRSTime来不及的:192
0. I<F3900 F3997[M1{↑饿-16},A3955(向92,距10,皮果),A3958(距51,向27,棒),A3962(距23,向87,棒),A3963(向92,距10,果),飞↑...
1. I<F3825 F5124[M1{↑饿-16},A5087(向267,距12,皮果),A5091(向342,距86,棒),A4196(距26,向272,棒),A5096(向267,距12,果...)
2. I<F3900 F4055[M1{↑饿-16},A4015(向91,距10,皮果),A4018(距98,向14,棒),A4022(距23,向88,棒),A4023(向91,距10,果),飞↑...

=============================== 2 行为化Fo ===============================
第 2/10 个,时序:F3997[M1{↑饿-16},A3955(向92,距10,皮果),A3958(距51,向27,棒),A3962(距23,向87,棒),A3963(向92,距10,果)...

=============================== 3 hDemand ===============================
A3955(向92,距10,皮果) //21:22:20:089

第1条 饿 评分-14.50 激活成功 	{proto:F15174 pFos:(F643,F387,F1323,F518)} //21:22:21:093
Demand竞争 <<<== SUCCESS 共2条

=============================== 3 rSolution ===============================
任务源:饿 protoFo:F15174[M1{↑饿-16},A15171(距0,向62,皮果)] 已有方案数:0 任务分:-14.50 //21:22:21:095
第1步 R场景树枝点数 I:4 + Father:12 + Brother:40 = 总:56
第2步 转为候选集 总数:6
第5步 Anaylst匹配成功:6
第6步 排除不应期:6
第7步 排除FRSTime来不及的:6
0. I<F1323 F4435[M1{↑饿-16},A1320(距63,向58,皮果),A4387(向15,距92,棒),A4022(距23,向88,棒),A3963(向92,距1...)
```

```c
31051-代码段2:
说明: (如下两点,本来后来的root就更迫切,在竞争中胜出是正常的);
//由日志可见,饿了更饿先跑出hDemand,但它毕竟发生的早,迫切度只有10.47分;
//而[饿,皮果]->更饿,因为发生的迟,明显迫切度更高,有13.77分;
## 1. 任务迫切度: -13.77 分
    ︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹
    * ReasonDemandModel: F15424[M1{↑饿-16},A15421(向72,距0,皮果)]-> (普 | Other)
    ︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺
## 2. 任务迫切度: -10.47 分
    ︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹
    * ReasonDemandModel: F15419[M1{↑饿-16}]-> (普 | ActYes)
      > TOFoModel: F3997[M1{↑饿-16},A3955(向92,距10,皮果),A3958(距51,向27,棒),A3962(距23,向87,棒),A3963(向92,距10,果),飞↑,A3972(向154,距35,棒),A3973...
        - TOAlgModel: A3955(向92,距10,皮果) (普 | ActYes)
          # HDemandModel
        - ReasonDemandModel: F15422[M1{↑饿-16},A3955(向92,距10,皮果),A3958(距51,向27,棒),A3962(距23,向87,棒),A3963(向92,距10,果),飞↑,A3972(向154,距35,棒),A3973(向98,距0,果),A3978(向159,距36,棒),A3981(吃1)]-> (普 | Other)
    ︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺
```

| 31052 | 方案2: 以Root推进进度计入任务竞争分加权 => 实践分析 |
| --- | --- |
| 前验 | 先把当前正在执行中的canset的cutIndex算出比重,计入加权调试下,看是否有效; |
|  | 公式1: progress进度 = actionIndex已推进帧数 / targetIndex目标; |
|  | 公式2: hot热度 = 1 - cooledValue(progress)符合28定律的牛顿冷却曲线; |
|  | 公式3: progressScore进度分 = hot热度值 * demandScore任务分 |
| 疑问 | 可是父子任务可能有多层,即HDemand可能在八层之后,那么它怎么综合计算`进度分`值呢? |
|  | 解答: 只需要判断Root下一层的canset,再下面不管先 `这样做的优点: 性能ok,精度足够`; |
| todo1 | 根据公式,计算出进度分 `T`; |
| todo2 | 将进度分参与到DemandManager.refreshCmvCacheSort()方法中 `T`; |
| 结果 | 改后回测见31052-代码段: 任务1的F3997有进度分5.79分,使其可以排序战胜Root2,成功激活; |

```c
31052-代码段
//1. Root1
︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹
* ReasonDemandModel: F15509[M1{↑饿-16}]-> (普 | ActYes)
  > TOFoModel: F3997[M1{↑饿-16},A3955(向92,距10,皮果),A3958(距51,向27,棒),A3962(距23,向87,棒),A3963(向92,距10,果),飞↑,A3972(向154,距35,棒),A3973(向98,距0,果),A3978(向159,距36,棒),A3981(吃1)]-> (普 | Runing)
    - TOAlgModel: A3955(向92,距10,皮果) (普 | OuterBack)
      # HDemandModel
    - ReasonDemandModel: F15511[M1{↑饿-16},A3955(向92,距10,皮果),A3958(距51,向27,棒),A3962(距23,向87,棒),A3963(向92,距10,果),飞↑,A3972(向154,距35,棒),A3973(向98,距0,果),A3978(向159,距36,棒),A3981(吃1)]-> (普 | Other)
︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺

//2. Root2
︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹︹
* ReasonDemandModel: F15513[M1{↑饿-16},A14914(距0,向130,皮果)]-> (普 | Other)
︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺︺

//3. 排序日志;
任务分:10.47 + 最终进度分:5.79 = 总分:16.26
  * cansetFo: F3997 Runing (2/10) 进度:0.10 热度:0.55 进度分:5.79
任务分:14.20 + 最终进度分:0.00 = 总分:14.20
```

```c
31053-测得有皮果hSolution无计可施问题 (取不到H场景树导致);
说明: 当前情况说明: 见31052-代码段日志=>竞争加权测试ok了,而下方日志可见=>h任务也可以顺利激活了;
问题: 查下FZ918中训练的hCanset未能在此处迁移使用到,查下原因;
复现: `FZ918,路下出生,饿,鸟身上丢给它一个带皮果`;
=============================== 4 hSolution ===============================
目标:A3955(向92,距10,皮果) 已有S数:0
第1步 H场景树枝点数 I:1 + Father:0 + Brother:0 = 总:1 //注意: 这里TCScene场景树仅取到自己,没迁移到别的
第2步 转为候选集 总数:0
第5步 Anaylst匹配成功:0
第6步 排除不应期:0
第7步 排除FRSTime来不及的:0
>>>>>> hSolution 无计可施

问题: hSolution的第1步,显示场景做就只取到自己(i有1条,f和b全是0条),没把以前的hCanset所在场景迁移过来;
分析: 在TCScene.hGetSceneTree()中,是从hScene(即rCanset)取F和B;
线索: 但rCanset本来也没啥抽具象关联,所以取到的F和B就全是0条喽;
求解: 而只有rScene才有丰富的抽具象关系,rCanset是没有的;
思路: 先把允许迁移的入口放宽,让它能迁移到,至于后面测试中如果发现放太宽带来了问题,再依问题带来的线索进行收窄;
所以: 有把迁移入口放宽的方案如下几种:
方案1. 改下使rCanset抽具象关系丰富化,使之能迁移到 `5%`;
  * 缺点: rCanset本身还挂在rScene之下呢,它再抽具象也没啥用,必须到rScene的抽具象关联中找迁移试下;
方案2. 借由rScene实现迁移: 直接从rScene的抽具象关联中找F和B迁移;
  * 比如: 在自己家修东西需要找下工具箱,在别人家修东西也可以问下他家有没有工具箱;
方案3. 借由Alg的抽具象关联实现迁移;
  * 比如: 无论在哪里(与环境无关),饿了首先想到买饭或做饭;
抉择: 因为方案2还有点约束(有rScene抽具象关系),不至于像方案3会完全放飞(脱离场景),所以优先选方案2,不行再选方案3;
调试: 训练一个新的hCanset出来,然后看下它的网络结构,分析下方案23哪个能行,怎样能顺利迁移给别的rScene;
```

***

## n31p06 重跑学搬运

在跑31053时,测得一个严重问题,在n31p05时学会的搬运不成立:
1. 因为当时学会的是:hCanset[距0有皮果1,踢,距15有皮果2] //原日志为:F27769[M1{↑饿-16},A27753(距0,向229,皮果),踢↑,A27760(距8,向96,皮果)]
2. 而rCanset的第2帧是:[距11有皮果3];
3. 然后`31026-代码段2`中,feedbackTOR其实反馈的是`A27753(距0,向229,皮果)`,它是距0有皮果1;
4. 所以,与踢压根无关,在踢之前已经反馈了;
5. 问题: 即A27753已经反馈了hDemand,而不是后面的A27760,本节应先解决此问题后,再继续上面的`学会和运用`;

| 31061 | 方案制定 |
| --- | --- |
| todo1 | 把OR反省触发习得newHCanset改为在feedbackTOR中就触发 `T`; |
|  | 优点: 可以避免后面的`踢和有皮果`这些其实与hCanset事实发生无关的帧被加到hCanset后段; |

| 31062 | feedbackTOR反馈不准确问题: 问题分析与方案制定; |
| --- | --- |
| 问题 | feedbackTOR的mcIsBro太宽泛,导致newHCanset极易生成的问题 |
| 说明 | 说白了,这个疑问是: **feedbackTOR太容易匹配导致生成的H不够准确问题**; |
| 外例 | 1. 我在找锤子的过程中看到砖头,是不是就反馈ok了; |
|  | 2. 如果我拿到砖头后,又看到了锤子呢? (是否要再生成一个newHCanset?) |
|  | 3. 二者的匹配度是不同的,锤子生成的hCanset,肯定是比砖头生成的hCanset更容易竞争战胜的; |
| 问题 | 导致H极易达成,但其实压根解决不了R的问题 |
| 原则 | **如果H不准确,那么R也会受其拖累,看起来进度很6,但最终R没啥效果;** |
| 内例 | 路边带皮果有了,不表示路中带皮果有了 (不能动不动就说已经达成了); |
| 回查 | 查下以前为什么要写mcIsBro来着; |
|  | 解答: 经查,当时白话叫"猜测尝试",即`mcIsBro应该能行,试试看的意思` (参考3014b-方案5); |
|  | 缺点: 既然是"猜测尝试",那么一刀切的认为现在的反馈可用,显然是不行的; |
|  | 线索: 用**相对解矛盾**的原则 (绝对无解,则尝试使相对矛盾的兄弟协作,把死循环变良循环),来分析解决此问题; |
|  | 思路: 应该开放接受持续的反馈才对,即拿到砖头后,又看到锤子,应该放弃砖头拿起锤子; |
| 方案 | 支持feedbackTOR持续接受更高准确的反馈,即"支持多次反馈,且只有更高匹配度的才能持续反馈进来"; |
| 结果 | 本节分析了feedbackTOR中mcIsBro导致反馈不准确的问题,并制定方案 `实践转下表`; |

| 31063 | feedbackTOR反馈不准确问题: 实践规划; |
| --- | --- |
| todo1 | 在feedbackTOR中受到反馈后,HAlg为OuterBack状态的也能接受持续反馈 `T`; |
| todo2 | 持续反馈时,要判断新反馈的匹配度更高,才可以将新反馈的把旧反馈的替换掉; |
|  | 备注: 关于怎么计算匹配度 (参考31064); |
| todo3 | 如果是actionIndex以往帧接受持续反馈时,需先评价下返工是否值得 `先不支持,真正需要时再来做`; |
|  | > 先不支持: 先不支持以往帧的持续反馈,因为支持返工评价还是比较麻烦的; |
|  | > 说明: 这涉及到两个一模一样的rCanset之间pk, 比如:已做了一半的饭,发现有更好的方法做更好,是否立即重新做? |

| 31064 | 31063-todo2展开分析: 如何判断本次反馈是否比旧有反馈更匹配 |
| --- | --- |
| 现结果 | protoAlg和cansetA在abs有交集: 交集与protoA的匹配度可计算 & 交集与cansetA的匹配度可计算; |
| 方案1 | protoA和cansetA,分别与交集,计算平均匹配度,二者相乘得到综合匹配度 `5%`; |
|  | 缺点: 此方案可能受干扰,感觉不如方案2; |
| 方案2 | 交集中的每一条,分别与protoA和cansetA取出两个匹配度,并相乘,找出相乘值最大的,做为最终匹配度 `5%`; |
|  | 分析: 此方案算是很单纯的匹配度竞争了,且没有方案1的问题(排除了干扰); |
|  | 示例: 美术生要找粉红色,找到了紫色,有70%匹配,但并不行,找到红色,有90%匹配,但依然不行; |
|  | 缺点: 如上示例可见,"hAlg的匹配度"与"是否有用"=>并不正相关,所以此方案pass; |
|  | 结果: 要想解决此问题,就必须回归到时序层面,来识别反思评价解决 `转方案3`; |
| 方案3 | 反思识别评价方案: 每次反馈时进行反思识别(功用反思)分析一下满意度(评价反馈的满意度) `95%`; |
| A | 示例1: 比如看到碎砖,用来当锤子不满意; |
|  | 步骤1: 将每次反馈代入原rCanset生成regroupFo; |
|  | 步骤2: 并从rCanset候选集中识别 (候选集 = solutionFoRankingV3.rank()结果); |
|  | 步骤3: 以识别结果在sort中的index做为满意度 (越靠前越满意); |
| B | 再深入分析可行性: 介入示例分析下此方案的细节; |
|  | 示例2: 如果是带刺的木头呢?是否能当锤子?看到带刺的木头想的不是是否和锤子像,而是: |
|  | >>> a. 想像这是否能行: 能否顺利完成砸钉子的任务(即肯定会regroup,以及候选集内时序识别) |
|  | >>> b. 想下刺是不是会伤到自己? (本表不涉及,不必管这条); |
|  | >>> 分析. 其实a和b都会去想,但本例主要涉及a,至于b以前已经做过,在别处会触发,此处不管它; |
| 结果 | 本表最终方案还是3,但深入分析后,有几大问题 `转下表31065` |

| 31065 | 方案3-用反思识别评价H反馈准确度: 分析此方案的几大问题; |
| --- | --- |
| 问题1 | 此方案超出了当前正在执行中的rCanset的范畴,即此方案会有越界风险; |
|  | 说明: 超出当前rCanset,不符合开发原则,也会让问题变的复杂; |
|  | 目标: 所以需要先分析下: "解决越界问题" 或 "使越界问题可控范围内" |
|  | 思路1. 仅做为反思评价的话,越界也没啥 |
|  | 思路2. 何况有regroup全含匹配限定着,也越界不了多少; |
|  | 所以: 越界问题可以先不管它,应该不至于影响本方案的推进 `暂不管`; |
| 问题2 | 用于识别的候选集`solutionFoRankingV3.rank()结果`,它有些已迁移,但大部分并没有迁移; |
|  | 说明: 那么这些候选集中识别?迁移过的,没迁移的,是否要都处理下,使之可以公平执行识别评价流程? |
|  | 查下: 现在的solutionFoRankingV3是怎么竞争的,毕竟它也排除掉了(场景树)的影响; |

***

## n31pN TODO备忘

> 将一些,目前需求不明确,或者还没到时候的备忘于此,时机成熟再做;

* 2023.12.17: 支持连续帧rInput (连续视觉);
  - 本次起因: 因为31021分析过Root合并避免重复多次执行的问题,而洽好越是连续帧rInput,31021中的合并就越跑的顺当,所以就想到写连续帧rInput;
  - 相关回顾: 以往是有过多次做连续帧的想法的,但需求都不太成熟,所以先没做 (本次需求也不迫切,因为没连续帧也大致不耽误做31021中的ROOT合并问题);
  - 方案细节: 做了连续视觉后,大几率inModels瞬时序列也要支持合并功能,不然4-7帧肯定就不够嘛;
* 2024.01.02: 支持多码感官和特征模块;
  - 方案细节: 一样需要支持合并功能(比较通用的压缩算法);
* 2024.01.10: 学搬运后半部分(第10步训练),因为有皮果是相对位置,而小鸟看不到路面,所以小鸟要知道把有皮果扔路上,必须以木棒位置为参考;
  - 方案: 即,实现搬运后,要想真正掌握好这一技能,需要RL多跑几轮,各个位置出生,各个位置扔木棒,来尝试hCanset,踢不同方向将其搬运到路上;

<br><br><br><br><br>
