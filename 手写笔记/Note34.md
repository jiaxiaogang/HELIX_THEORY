# 测试推进细节修正的问题，并整理推进(觅食 & 飞躲 & 踢搬运)三项的多向连续训练,以及三项融合训练

在前面,已经学会搬运,且会用搬运来踢坚果到路上,至此所有单轮的训练项目全部通过了,以下开始对这些项目进行连续行为训练,以及融合在一起训练等;

***

<!-- TOC -->

- [测试推进细节修正的问题，并整理推进(觅食 & 飞躲 & 踢搬运)三项的多向连续训练,以及三项融合训练](#测试推进细节修正的问题并整理推进觅食--飞躲--踢搬运三项的多向连续训练以及三项融合训练)
  - [n34p01 回测简化的嵌套关系、OutSPDic存取、新版Solution、CansetV3类比等](#n34p01-回测简化的嵌套关系outspdic存取新版solutioncansetv3类比等)
  - [n34p02 整理下HE的多码特征计划](#n34p02-整理下he的多码特征计划)
  - [n34p03 多码特征的：感官算法 和 感官模型](#n34p03-多码特征的感官算法-和-感官模型)
  - [n34p04 多码特征的：组码表征 和 特征表征](#n34p04-多码特征的组码表征-和-特征表征)
  - [n34p05 多码特征的：组码识别 和 特征识别](#n34p05-多码特征的组码识别-和-特征识别)
  - [n34p06 多码特征的：组码类比 和 特征类比](#n34p06-多码特征的组码类比-和-特征类比)
  - [n34p07 多码特征的：初步回测修BUG细节优化等](#n34p07-多码特征的初步回测修bug细节优化等)
  - [n34p08 多码特征的：独立迭代组码索引](#n34p08-多码特征的独立迭代组码索引)
  - [n34p09 多码特征回顾A：整理回顾下从特征抽象 到 识别 到 准确度的 流程](#n34p09-多码特征回顾a整理回顾下从特征抽象-到-识别-到-准确度的-流程)
  - [n34p10 多码特征回测B：多测下整套流程：从特征抽象 到 更准确的识别（抽象结果）](#n34p10-多码特征回测b多测下整套流程从特征抽象-到-更准确的识别抽象结果)
  - [n34p11 多码特征回测C：手训和RL强训](#n34p11-多码特征回测c手训和rl强训)
  - [n34p12 多码特征回测D：特征最终作用于时序的SP稳定性](#n34p12-多码特征回测d特征最终作用于时序的sp稳定性)
  - [n34p13 从组特征 到 特征嵌套](#n34p13-从组特征-到-特征嵌套)

<!-- /TOC -->

***

## n34p01 回测简化的嵌套关系、OutSPDic存取、新版Solution、CansetV3类比等
`CreateTime 2025.03.13`

| 34011 | 重新训练下三步,并存为FZ103（参考33132） |
| --- | --- |
| FZ1031 | 认知模式:`饿,扔随机坚果,不吃,又饿`x50轮 (RL工具跑:无皮学饿) (参考33013-步骤) `T`; |
| FZ1032 | 认知模式:`饿,扔附近坚果,随机连飞3下(如飞中吸吮反射)`x100轮 (RL工具跑:学吃) (参考28173-2学飞) `T`; |
| FZ1033 | 动物模式:`饿,某方向附近扔果` (注: 看它能不能自行飞吃到,如果飞错,也不要干预它,多试错训练几次); |

| 34012 | 训练中观察注意 |
| --- | --- |
| 测项1 | 观察新的构建Canset四处代码。 |
| 测项2 | 看下推举V3算法，能不能正常推举和构建映射等。 |
| 测项3 | 看下OutSPDic的存取。 |
| 测项4 | 看下新版Solution仅从F求解情况。 |
| 测项5 | 看下CansetV3类比器，能不能正常类比出结果。 |
| 测项6 | 递归更早前的测试项：看下hSolution还会不会总是无解了。 |
| 测项7 | 递归更早前的测试项：第3步试错训练,看`有向无距果场景`在不断竞争中SP浮现的怎么样; |

***

## n34p02 整理下HE的多码特征计划
`CreateTime 2025.03.14`

本节借着长字符串相似度识别问题，把HE一直没做的多码特征整理下，主要是从稀疏粒度到特征层，以前是单码特征，本来计划是到v3时再做多码特征，不过一来是近年HE的改动不再过于推晚不做早，二来是乌鸦演示对系统的全面性细节性要求高于原先预计，所以感官端这里跟一下进度也无不可。

**34021、需求**
老同事的需求，想搞这样的数据库。在HE系统的数据库基础上分析如下（有些像加了解释性的CNN，也可以到网上自行找“CNN可解释性研究”，应该还有别的可行方案）。

**34022、数据库**
1. 稀疏码：一个字符串有一千字符，用这一千字符，生成1000个稀疏码（每个码必须是一个值类型）。
2. 稀疏索引：把各个稀疏码做成一个数组索引（按从小到大排序）。
3. 稀疏粒度：可以对长字符串按1/10，1/100，1/1000粒度去分别做多粒度分组。按1/10粒度，就是100字符一粒，用这一粒生成一个平均值，计为一条该粒度的稀疏码。
4. 特征：其实就是整个字符串，在该例中，计为：它的字符串特征（因为该例不涉及比如视觉那样的多特征，所以只需要走到特征这一级就够用了）。
5. 特征与稀疏码：一组稀疏码，组成一个特征（比如1/10粒度的特征就含10个稀疏码）。
6. 特征引用：每个特征引用了哪些稀疏码，比如1/10粒度时，有100个稀疏码，特征要分别与它的100个稀疏码创建一个关联（叫refPorts关联）（这个关联以后要用来做启发式搜索的）。
7. 关联强度：以后搜索时，每一次激活成功后，要对这个refPorts中记一次strong+1（也是以后用来搜索竞争用的）。

8. 另1、粒度关联：在1/10，1/100，1/1000各粒度产生出的稀疏码间，要建立关联，比如：一千字符，产出1/10粒度稀疏10个，它的每块分别与1/100粒度产生的100个中的10个码建立粒度关联splitPorts。
9. 另2、特征错位：另外为了准确度，也可以做错位层（即以0.5个粒度进行）（这条也是为了性能，因为粗粒度时，筛选的越准，它后面性能就越好）。
10. 另3、再后面的概念、时序、价值，这些在该需求不涉及，砍掉。

**34023、工作步骤**
1. 输入长字符串。
2. 按从粗到细粒度，分别拆分成稀疏码（如1/10，产出10个稀疏码）。
3. 每个产出码，都在各自粒度的索引序列中，可以向上下相近的值扩展30%（比如现在平均值是666，那么找到索引后，分别向从小大到的索引序列两测扩15%）（相当于找30%的值相近度）。
4. 然后分别通过这些稀疏码的refPorts找对应特征索引（记住，此时并不激活特征，只是取出refPorts索引而已，性能上没问题）。

5. 根据各粒度取到的refPorts，计算匹配度（注意：稀疏码索引时，就已经知道相近度了，这是微观相似度，到宏观特征的相似度由乘积获得）。
6. 通过refPorts取出强度（过去激活次数）。
7. 单粒度内通过refPorts取到目标的次数（因为单个粒度也有多个码，索引时可以指向同一个refPort.target特征多次）。
8. 多粒度间通过refPorts取到目标的次数（多个粒度取refPort.target特征虽然各自在不同粒度上，但它们有splitPorts粒度关联，可以来判断refPort.target是不是指向同一个特征）。
9. 取次数其实是在取交（相当于缩小范围，即：每一新取refPorts时，相当于直接在上一轮的结果中取）。

10. 竞争：根据以上匹配度、强度、索引到目标次数，综合竞争（找出各粒度都比较匹配的特征结果）。
11. 结果：最后得到结果仍是数组，并且是有相似度，且在一级级向细粒度上解析，可以完全还原它的内容，即：具备可解释性）。

**小结：以上大概讲了从稀疏码到特征的表征和识别方式。**

| 34024 | 用图表示稀疏码到特征的流程 |
| --- | --- |
| 示图 | ![](assets/734_稀疏码到特征.png) |
| 步骤1 | 如图，我们从粗粒度开始索引，它因为粒度粗（所以refPorts结果少），再加上扩30%的索引（ref结果会多些，但因为粒度粗，在可接受范围），做为一级结果。 |
| 步骤2 | 然后分两条路径：一条是根据取到的粗结果特征，向细粒度找splitPorts。另一条从细粒度稀疏码，向refPorts找细粒度特征。 |
| 步骤3 | 两条路径的结果取交集（或结果计数，计数多的更准确），然后根据匹配度竞争，再保留可接受数量的二级结果。 |
| 步骤5 | 再分两条路径：二级结果向splitPorts取，三级粒度稀疏码向refPorts取。 |
| 步骤6 | 再两条路径的结果取交集（或结果计数，计数多的更准确），然后根据匹配度竞争，再保留可接受数量的三级结果。 |
| 结果 | 像如图中，一级取到4条(ABCD)，二级2条(B9,D9)，三级1条(D99)，当然图只是个示意，真要跑的是九格全跑，不可能只跑第9格。 |

**小结：34024中，通过示图详细说明了从稀疏码到特征的识别过程。**

| 34025 | 非视觉中心错位，导致识别不准确的问题。 |
| --- | --- |
| 问题说明 | 识别时，原感官数据有错位问题，比如视觉往往不在视觉中心，导致错位，导致识别不准。 |
| 思路分析 | 当识别有价值影响（值得关注）的信号（如危险）时（此时已经有了任务），它正视目标然后能实现更准确识别，并解决任务。 |
| 正面解答 | 那这个：”正视目标”本身就是解决任务的第一个步骤而已，即：我们是为了解决任务，才正视目标，识别目标，精准解决任务。 |
| 反面解答 | 而不是为了能解决识别的非视觉中心错位问题，而专门去实现正视目标，或者平移图像实现识别。 |
| 总结 | 即：此问题，融入到整个思维系统中去解决了，而不是通过感官算法解决（即我老以前说的，脖子动是行为，而不是主动视觉的功能）。 |

**小结：34025中，描述了被动视觉是怎样实现正视的，解答了非视觉中心导致的识别不准确问题。**
**总结：当前he4o的v2版本不做多码特征，此笔记中多码特征部分，和splitPorts粒度关联并未工程化，但整个做法与以往HE的做法是同源的。**

***

## n34p03 多码特征的：感官算法 和 感官模型
`CreateTime 2025.03.15`

上节中，分析了多码特征的一些细则，想着就着思路，就写写先，也不必非要等下版本再做，毕竟图片识别的测试方式实现起来也简单。

注：本次多码特征的迭代，以1万像素图片的视觉为例。

| 34031 | 多码特征的实践之：感官部分 |
| --- | --- |
| 说明 | 特征分索引模块（粒度层级索引） 和 特征组节点模块（9格为1个节点）。 |
| TODO1 | 每个概念有多个特征，比如视觉有HSB三个特征 `T`。 |
| TODO2 | 每个特征有多个粒度，比如总宽100像素，转为点数81，level分4层，每层9格，又下挂子层9格 `T`。 |
|  | > 因为是多层，可以用嵌套分形数据结构，一父多子，子又含多子。 |
| TODO3 | 每个粒度都是一个字典<K=x_y，V=H或S或B值> `T`。 |
| TODO4 | 把以上写成视觉感官模型AIVisionAlgsModelV2，下面写HColors、SColors、BColors三个特征 `T`。 |
| TODO5 | 做个样图测试createTestImage()，看视觉感官处理色值矩阵正确 `T`。 |

***

## n34p04 多码特征的：组码表征 和 特征表征
`CreateTime 2025.03.16`

说明：稀疏码多粒度表征，其实最后落实到代码上，就是组码表征，因为多粒度是感官层的说法，到了表征层，就必须拆开一组组，一条条的去表征，说白了，就是树的耦合必须全打开。

| 34041 | 多码特征的实践之：稀疏码的：粒度树索引部分 |
| --- | --- |
| 说明 | 粒度树其实还是索引（也还属于稀疏码，它是值类型）。 |
| 问题1 | 需要粒度树索引吗？ |
|  | 正据：粒度树可用于识别过程中性能保证等（参考34024-示图）。 |
|  | 反据：性能保证只是尽可能的使用粗粒度（其实只是表征了level层级，具体实现是通过细一级9宫的相似度判断的）（参考34042-分析3）。 |
|  | 思路：那么粒度树是不是只需要存在感官层面，和特征中有level就行，在稀疏码模块应该不需要它？ |
| 问题2 | 用单码向ref索引是不可取的，性能上不行，并且太泛，压根找不到想要的特征， |
|  | 思路：稀疏必须支持组码（九宫打包成块）（或者叫九宫组码）这样做的好处，首先九宫组码可以向ref索引识别特征。 |
| 总结 | 就是组码节点的content_ps有九位单码组成，且它是有序的，顺序就是从第一行到最第三行，每行左从至右各三位 `T`。 |

| 34042 | 多码特征的实践之：特征节点部分 |
| --- | --- |
| 说明 | 粒度树的父层，可能有多个子层。而特征节点则不然，它以一组小特征或稀疏码组成，精准的表达它的具象信息内含。 |
| 分析1 | 分析下怎么打包具象特征组，以构建具象特征。 |
|  | > 特征节点：特征组，是给一组特征的别名，它会被建成特征节点（然后有具象特征，也会归纳抽象特征）。 |
| 分析2 | 分析下怎么写类比归纳找规律，以构建抽象特征。 |
|  | > 抽象特征：特征明显的稳定的（一般是细粒度层）（找出规律的抽象特征：比如眼角的样子）。 |
| 分析3 | 分析下，用哪个粒度层做组，来表征特征？ |
|  | > 性能考虑：如果粗粒度一级就能表征到很相似的匹配到特征，那么优先使用粗粒度（节能省空间，其实就是压缩算法）。 |
|  | > 怎样判定粗粒度相似呢？细一级粒度的九宫的码值没什么差别，即表示它相似（比如：九宫全是亮度1，那我用粗一级一个码就表示了）。 |
|  | 总结：其实就是把所有九宫一致的组码去掉，自然就剩下不同部分了（不同部分就是具象特征的内容）。 |
| 分析4 | 特征是指针类型，它含数个码，可是特征怎么表征这些码呢？这些码有序吗？有位置吗？有层级吗？如下图： |
|  | ![](assets/735_特征中的多码表征分析.png) |
|  | 1. 根据以上性能考虑，要尽量使用粗粒度码，所以特征里的码，必须包含level层级，因为3层一点和4层一点是完全不同的。 |
|  | 2. 根据以上示图分析，即使一模一样的粗粒度，以及其细一层也一样，粗粒度的位置也可能不同，所以必须包含xy值。 |
|  | 总结：特征里的多码，必须包含：level_x_y的表征。 |
| 总结 | 就是特征节点，必须除了content_ps中存组码，还要把每个组码的level,x,y存下来 `T`。 |

| 34043 | TODOLIST |
| --- | --- |
| TODO1 | 视觉多粒度中，所有单码的装箱 `T`。 |
| TODO2 | 写AIGroupValueNode和组码装箱（用下面的构建器） `T`。 |
| TODO3 | 写AIFeatureNode和特征装箱（用下面的构建器） `T`。 |
| TODO4 | 写通用构建器（即可以构建组码节点，又可以构建特征节点），并支持本地防重，组分关联等 `T`。 |
| TODO5 | 写特征压缩算法，所有9宫相似的组码，都压缩掉，只保留有特异性的组码 `T`。 |
| TODO6 | AIFeatureNode不仅有content_ps，还有level,x,y，所以把它也加到生成header里，使之可防重 `T`。 |
| TODO7 | 性能优化：稀疏码要限制下精度（先通过输入端+装箱时）两步都限制了，以后有机会再更新成一步自动计算 `T`。 |
| TODO8 | 测试工具：写生成手写数字的方法 `写的不完美，先试试用，后面再改进 T`。 |

***

## n34p05 多码特征的：组码识别 和 特征识别
`CreateTime 2025.03.19`

在上节中，做了组码和特征的表征，本节搞识别。

| 34051 | 组码识别 |
| --- | --- |
| 结果 | 参考概念识别，先进行单码识别，然后边ref，边乘积相近度，边求交集（元素匹配计数）就行了 `T`。 |

| 34052 | 特征识别 |
| --- | --- |
| TODO1 | 参考概念识别，先进行组码识别，然后边ref，边乘积相近度，边求 交集（元素匹配计数）就行了 `T`。 |
| TODO2 | 性能优化：为了性能把level,x,y都存到组码的refPort里，便于不取特征，就能计算level,x,y的匹配度 `T`。 |
| TODO3 | 特征识别需要判断level，如果层级错乱几乎是无法匹配上的，但错位是可以的，比如近景远景的匹配，所以可以计算level差值一样的计为了组 `T`。 |
| TODO4 | 特征识别需要判断x,y值，不然位置错乱肯定无法匹配上的，可以分别以x和y从小到大排序，排成两个序列，然后根据顺序相似度来计算xy相似度 `T`。 |

| 34053 | 特征识别中的`组码位置匹配度` |
| --- | --- |
| 说明 | 特征识别中，其局部位置是否都正确？即判断组码的位置是否正确，怎么判断？怎么求出这个匹配度？ |
| 分析 | 参考34042-分析4，原本留下了level,x,y数据，所以可以用于计算。 |
| 旧方案 | 采用根据y,x,level三步从小到大排序，对特征中的组码content_ps进行排序，那么是否顺序相同者即位置匹配？ |
|  | 解答：顺序相同，不表示位置正确，比如李四在第一排张三后面，王五可能在第二排张三下面。二人都在张三顺序后，但位置却是一个在右一个在下完全不同。 |
| 新方案 | 如下图，还是得用xy来计算推测它应该出现的位置，然后根据这个符合推测范围，来计算匹配度。 |
| 示图 | ![](assets/736_特征的组码位置匹配度.png) |
| 结果 | 选定新方案，进行代码实践，并测试 `T`。 |

***

## n34p06 多码特征的：组码类比 和 特征类比
`CreateTime 2025.03.20`

在上节中，做了组码和特征的识别，本节搞类比。

| 34061 | 组码类比 |
| --- | --- |
| 重点 | 在于9宫一一相对。 |
| TODO | 可以参考以前单码概念的类比，计算单码的重要程度，以类比归纳得出抽象组码 `T`。 |

| 34062 | 特征类比 |
| --- | --- |
| 重点 | 在于缩放和平移：即无论是缩放还是平移，都是取相对位置，而相对位置，其实还是数组按顺序的取交（还是类比归纳）。 |
| 方案1 | 可以参考以前时序的类比，单纯以mIsC来类比归纳出特征的抽象 `废弃 T`。 |
|  | 缺点: 因为特征可能包含很多组码,而组码又互相抽具象越来越多,所以用mIsC的方案1,可能并没有那么好用。 |
| 方案2 | 可以在特征识别后(识别时有局部位置的正确判断),把protoAssIndexDic直接存下来,到时用映射来类比 `T`。 |
| 结果 | 暂选定方案2进行代码实践 `T`; |

***

## n34p07 多码特征的：初步回测修BUG细节优化等
`CreateTime 2025.03.22`

在前几节中，用6天时间顺便把多码特征写了（包括从1w像素图像视觉感官算法，感官多粒度模型，组码表征，特征压缩，特征的表征，组码识别，特征识别，组码类比归纳抽象，特征类比归纳抽象），本节回测下。

| 34071 | BUG LIST |
| --- | --- |
| BUG1 | 特征识别时，组码的位置`符合度`经常算出0，查下为什么 `T`。 |
| 结果 | 后测得若干BUG，都直接在代码里分析并修复了，此处略不记。 |

| 34072 | 优化 TODOLIST |
| --- | --- |
| 优化1 | 把位置符合度存为特征中的组码相似度（而不是竞争完就没了，类比时还要用它呢）`T`。 |
| 优化2 | 位置符合度算法，由一点判断，改成多点共同判断。 |
| 优化3 | 现在的性能还很问题，得用性能debug工具，过一下性能，该优化的优化下 `T`。 |
| 性能4 | 组码识别有性能问题，40个组码x各9个码x各激活80个单码x各取10个refPorts，最内层循环得跑30w次，性能很慢。 |
|  | 性能4A: 可以用取交方式来解决下，即第1码ref到的，在第2码时也必须从中取（不然就不全含了），这样让漏斗越来越小，让循环少些 `T`。 |
|  | >>> 总结: 这个取交本身的性能就不好，因为它需要把G码都取出来判断取交，并且特征有40个组码每个组码含9个单码它就得判断360次。 |
|  | >>> 分析: 但仍慢，仅靠最内层加`取交防重`是不行的，判30w防重都吃不消，得每一层都尽量加上防重 `T`。 |
|  | 性能4B: 为每一层都加上cache，统一设计下加到瞬时序列的ShortModel里，只要ShortModel不销毁或被新short使用，继承过来 `T`。 |
|  | >>> 总结: 跑了下命中率从12%，多次重复后跑到3x%，但它并没有从根本上解决组码循环太多的问题。 |
|  | 性能4D: 索引G码时，把现在单码的整个refPorts分成x_y共9个refPorts，这样就可以把循环从40w变成5w `T`。 |
|  | >>> 总结: 这个确实有效，但感觉不太够，得加强一下，单用xy来分，只能减少循环数为1/9，但性能还是达不到理想效果。 |
| 总结 | 各种防重和缓存机制都加上了，虽然也有很大效果，但治标不治本，即使只循环8w次，也得2秒多 `转34081 T`。 |

| 34073 | 测试训练记录 |
| --- | --- |
| 记录1 | 用Mnist图片跑几张0和1，测试后能识别到，不过还不够准确，需要更多的抽象和更多的SP稳定性，所以需要更全面的测试训练，转下条。 |
| 记录2 | 搞下更全面的训练手段，比如看到8乌鸦点头就喂坚果，或再简化些：改成只有8号坚果可以吃，用强训工具来跑。 |

***

## n34p08 多码特征的：独立迭代组码索引
`CreateTime 2025.03.26`

在上节中，对多码特征进行了测试，修BUG，细节处理，优化等。不过最终测到组码识别慢的问题时，发现循环数太多，怎么优化也标治不标本，本节用于解决这一问题，实现一个独立的：组码索引。

原则：错觉是允许的，不过要尽量相对应来减少错觉。可以因性能而不精准，但不能因设计而常错。

| 34081 | 组码索引 方案1 |
| --- | --- |
| 问题 | 参考34072-性能4：本表分析一个治本的优化方法，把组码循环太多慢的问题彻底解决下。 |
| 思路 | 原问题根本上在于从单码到组码，之间需要太多循环了，其实只要我们直接对组码设计一个索引（跳过单码），就可以了。 |
| 回顾 | 原来的单码索引是以值序列，加相近度来的。 |
| 方案1 | 而组码索引完全可以由：`相对位置（可由顺序替代），平均值（绝对值大小），差值（值范围）`这些来试着实现（见下图方案分析）。 |
| 示图 | ![](assets/737_组码索引方案1.png) |
| 说明 | 如上图，得出四点线索： |
|  | 1、顺序：从小到大，先x后y，得出以上两张图A和图B排序路径一致。 |
|  | 2、平均：所有值求和/9，得出上A图平均值3，B图平均值7。 |
|  | 3、差值：最大减最小值，得出上A图差值4，B图差值4。 |
|  | 4、权重：各粒度组码的权重不同，A图level1宽81，B图level3宽9，假如此时所有码总宽=192：A权重=81/192=42%，B权重-9/192=5%。 |
| 疑问1 | 无法区分1-2-2-3-3-3-4-4-5和1-3-3-3-3-3-3-3-4=5的区别，因为二者完全可以排成：顺序，平均值，差值，都一样。 |
| 解决1 | 把顺序两两之间的差值求出来，比如：122333445，计为1(1)2(0)2(1)3(0)3(0)3(1)4(0)4(1)5,共17位。 |
|  | 注：差值精度可以低一些，比如先定为0.1。 |
| 疑问2 | 平均值呢？也要照顾下，只要信息体现出的差异都得照顾下。 |
| 解决2 | 可以把平均值当成末位，共18位，不过精度可以再粗一些，比如：0.25，一共1到4四个可能值。 |
| 疑问3 | 精度写死成太粗，会不会导致索引到的数据量太大，或太小，不好调整。 |
| 解决3 | 精度完全可以尽量细一些，取的时候按范围取就行了，比如精度是0.03，那我取0.2的范围的时候，取相邻共7条就行了。 |
| 疑问4 | 精度写死成太细，又会导致索引太多，刚开机会显得系统发呆一会反应慢。 |
| 解决4 | 这个要自行取舍一下（当然也可以建多个精度的索引，以空间换时间，但这涉及到多个索引同步的问题，暂不做那么深入复杂）。 |
|  | 示例：`相近的明暗 或 相近的颜色`我们单独看也很难辨别（意思是其实组码差值和平均值的精度也没必要那么高）。 |
| 重点 | **其实本表给组码建的索引，也相当于替代了组码识别，直接可以由索引取得相近的组码。** |
| TODO1 | 如上可以用顺序9位数的排序，组成一个1-9的索引路径来表示 `T`。 |
| TODO2 | 再把顺序中两两计算差值，按0.1精度转为1-9之间的数字，然后把这8个差值，插在1-9的路径间隙中 `T`。 |
| TODO3 | 再把平均值按0.25精度转为1-4之间的数字，然后把这1个平均值，插在17位的最后做为第18位 `T`。 |
| TODO4 | 可以参考原单码代码PNDATA & PNINDEX & PNVALUE，该复用的复用，该新增的比如命名PN_G_DATA来做新的即可 `T`。 |
| TODO5 | 把平均值从第18位，改成从小到大存在索引序列中，这个可以用来计算组码相近度 `T`。 |
| 回测 | 如上方案1写完后，经回测，索引太窄了，导致很难识别到，40多个组码的特征，可能只能识别到一两个，此问题转让下表解决。 |

| 34082 | 组码索引 方案2 |
| --- | --- |
| 起因 | 在上表中，方案1最终发现太窄了，本表迭代解决此问题。 |
| 原因 | 因为同一个概念的多张图，其变化也非常巨大，光线，角度，在微观的组码上任何一模一样的要求，都是几乎不可能的。 |
| 分析 | 表达组码的方式有很多，我们要找出合适的，它即可以索引到，又在宽窄程度上洽当，不至于索引不到，也不至于索引不准确。 |
| 矛盾 | 准确和能索引到，这二者本来是矛盾的，用相对来解决。 |
| 相对 | 所以在：左不能不准 和 右能索引到，二者之间做相对平衡。 |
| 原则1 | 所以组码索引一定要宽，只要能够达成组码这一微观层级，能够达到的功效即可（说白了，要判断，但只要一点点）。 |
| 原则2 | 索引要素一定要可以量化，并且可以求相近度。 |
| 回顾 | 方案1中，有三个要素：顺序、差值、均值。用这三个来界定组码本身没啥问题，只是不能太死，导致太窄索引不到。 |
| 思路 | 把以上三者分析下，能怎么放宽。 |
|  | 1、均值：已足够简化，也能够量化求相近度，暂不改。 |
|  | 2、差值：简化下，只把大于和小于均值分成两边，大的求均值bigV，小的求均值smallV，再二者求差值，这个也可以量化相近度。 |
|  | 3、顺序：顺序方案1也太严可简化下，只把均值两边的中心连线，得出方向值，这个可以量化相近度。 |
| 方案2 | 方向、差值、均值：分别建从小到大有序的组码索引。这三者共同划定：分别取xx%相近度然后乘积匹配度。 |
| 疑点1 | 方向不仅是向性，还有围成方或圆形，或者纯色，这些怎么表征成方向？ |
| 解答1 | 可暂不考虑这些做索引，只要支持方向就行，组码还是太微观了，不必搞那么复杂，真正的升华是从`位置符合度`才开始的。 |
| TODO1 | 方向：改为先分暗和明，然后二分界方向 `T`。 |
| TODO2 | 差值：可以考虑用max-min值，不过最好是用二分界的平均值一求差 `T`。 |
| TODO3 | 均值：值的计算仍是9值求均不变 `T`。 |
| TODO4 | 以上分别建索引，共三个索引，注意方向索引是loop首尾相接的 `T`。 |
| TODO5 | 组码识别跟着迭代下，改为三个索引乘积计算匹配度 `T`。 |
| TODO6 | 组码类比跟着迭代下，改为和单码类比的类比方式（因为现在组码的索引其实也类似单码方式了），而不再继续深入单码求类比 `T`。 |
| 结果 | 改后经测，巨大循环性能问题已ok `T`。 |

***

## n34p09 多码特征回顾A：整理回顾下从特征抽象 到 识别 到 准确度的 流程
`CreateTime 2025.03.29`

起因、因为组码还是太微观了，组码只是找出特征的过度，真正的特征识别还是要以：抽象特征和特征嵌套来主打。

| 34091 | 从 特征抽象 到 特征嵌套 |
| --- | --- |
| 1触发抽象 | 每次概念识别都进行概念类比，提升特征抽象性 `T`。 |
| 2习得抽象 | 从类比出关键特征（比如眼睛，鼻子，眼神，嘴角，表情等）。 |
| 3使用抽象 | 到识别关键特征，提升识别准确度（可识别交层特征，不要求全含）（比如单亮点，或长长的胡子弯线）。 |
|  | > 需求：抽象特征很难一模一样。只有不断向抽象做，才能慢慢并拢到`有共同的抽象特征`。 |
|  | > 问题：需要增强特征的抽象，不能只是似层抽象似层，这样会限定在似层+抽象一层的层级，很难得到很抽象的特征。 |
|  | > 分析：现在的特征识别没有要求似层（其实本来就很难仅识别似层，40多条组码很难要求都对应上），所以必然会识别到交层特征。 |
|  | > 解答：每每识别到交层特征，然后再类比类比，即可越来越抽象（层级+1）。 |
| 4特征嵌套 | 同时识别到多个抽象特征时，判断其位置符合度：即`根据一个protoT识别到多个局部特征assT`的位置符合度 `废弃 T`。 |
|  | > 问题：嵌套关系过于复杂，不到万不得已不建议采用。 |
|  | > 解答：具象特征匹配度低，但局部特征可能匹配度高（其实是有共同抽象，而不是特征嵌套），即只要识别到抽象特征，它就可以匹配上。 |
|  | > 示图：![](assets/738_抽象特征匹配示图.png) |
| 5提升准确 | 每一次识别到absT时，它更准确（因为局部匹配度总是高的）。 |
|  | > 说明：即慢慢抽象特征，最后识别到抽象概念时，它能够越来越准（proto与抽象特征的匹配度高，比如：多个0抽象出一圈曲线）。 |
|  | > 问题：如何避免过度抽象特征对准确度的影响？比如：0-9都互相类比，也能抽象出一个点特征，这个点哪哪都能识别到。 |
|  | > 分析：旧做法是概念只识别似层，但现在有了多码特征后，它很难只识别似层了，交层必然有在。 |
|  | > 结果：该问题，不仅有过度抽象的问题，也有类似的过度具象的问题，`转34092展开分析解决 T`。 |
| 6提升强度 | 每次识别到又会计数strong+1，所以优者更优竞争浮现。 |
| 7形成螺旋 | 竞争优胜者，又可以触发类比抽象，回到第1步，形成良性循环。 |
| 结果 | 本表特征嵌套没必要去掉了，但抽象有过度抽象的问题，转下表分析下。 |

| 34092 | 特征准确度：特征过度抽象或过度具象问题 |
| --- | --- |
| 方案1 | **思路：要不把非此即彼的：在似或交层，改成竞争规则，即有多交？（组码匹配数/率，比如40条匹配上10条即25%）。** |
| 示例 | 一切都是物体，它在匹配度上是100%成立的，一切都是自己，它在匹配度上也是100%成立的，但这个匹配数不应作用于竞争规则。 |
| 否定 | 但并不是越似层越好，或者越交层越好，我们只是需要从似和交之中，找出中间平衡点，过度似或过度交都不好。 |
| 方案2 | **识别时，不做匹配数判断，只在二次过滤，或者后面的场景时序或方案时序中，再决定你把前面识别的概念当成怎样的抽象层级来用。** |
| 思路 | 可以参考下原来的特征重要性算法，看看改下支持现在的特征重要性判断（也看下有没有SP的影响，最好把时序的SP稳定性也起到影响）。 |
| 分析 | 识别坚果可吃的时候，必须是无皮特征，而不能是识别成：物体，或者识别成：有没皮无所谓的特征（即二次过滤时，再由时序识别结果反过来做过滤）。 |
| 比如 | 只有8号坚果可吃的时候，比如此时识别有三条（1、proto8号坚果 2、任何8号坚果 3、不限号任意坚果），只有识别到的第2条的：`特征抽象层级最准确`。 |
|  | 1、抽象层级稳定（第3条任意坚果因过度抽象没限号而不稳定） |
|  | 2、强度强（比较抽象识别次数多所以强度Ok，第1条就是过度具象导致强度不够）。 |
| 回顾 | 回顾了下代码，现在的二次过滤稀疏码重要性，主要是对针对V相近度并不是均匀的，即可能0-1中，0.2到0.25差异很大也很重要，别的都无所谓。 |
| 否定 | 而本次主要是解决过度抽象和过度具象的问题，与二次过滤器并无关系，所以先否掉，转方案3。 |
| 方案3 | **就由SP稳定性来表达其是否过度抽象，不要搞那种SP反过来影响识别的事，那太复杂了。** |
| 说明 | 在IN预测时，自然会慢慢了解InSP是否不稳定。而在求解后的OUT预测时，自然会慢慢知道OutSP是否稳定。 |
| 白话 | 当你的任务是只有8号坚果能吃时8是合适的抽象度，如果你的任务是`带圈坚果都能吃`，那你把8和0都识别成带圈才是合适的抽象度。 |
|  | 说明：即算不算过度抽象，并不是识别算法说了算，而是其所在的时序的SP决定的。 |
| 抉择 | **方案1把似交和好坏直接对应上，这是不行的（因为似交与好坏并不是一一对应的，在不同任务中的合理抽象度各有不同。** |
|  | **方案2认为可以由SP反向影响识别结果，SP本身就在更后面，有用你就用，没用就别用，搞这种反向过滤太复杂了不可取。** |
|  | **方案3最好，该识别就识别，该SP就SP稳定性，不必搅和在一起。** |
| 结果1 | 选中方案3，即不用改代码，识别要全，为所有任务做好准备，然后不同的任务来决定各自哪个抽象度合理。 |
| 结果2 | 即由更全面的训练来决定合理抽象度 `参考34073 搞下只有8号坚果可吃 转下表`。 |

**小结：34091的7步太复杂了，简化下还是以前HE的循环流程：识别->抽象->更准识别->作用于任务->SP越来越找出稳定时序（参考34092-方案3&抉择&结果1&结果2）。**
**小结：在上表中回顾了一下以前的过度抽象没和SP搅在一起反向过滤，仍保持那一做法。**

***

## n34p10 多码特征回测B：多测下整套流程：从特征抽象 到 更准确的识别（抽象结果）
`CreateTime 2025.04.01`

在上节，略测了下特征类比抽象，本节继续，边测特征抽象，边测SP稳定性跑准确度 `转34101`。

| 34101 | 继续回归测试训练（参考34073） |
| --- | --- |
| 测试点1 | 多跑跑Mnist图，测下更多的特征抽象 `实测参考34102 T`。 |
| 测试点2 | 随着更多的特征抽象，能够使识别算法更准确（抽象是一般性特征，更容易匹配度高） `实测参考34103 T`。 |
| 测试点3 | 强训工具做一下只有8号坚果可以吃，来获取更多的SP稳定性，来慢慢跑出它可以准确识别到8（其实是SP稳定的准确认定8）`转n34p11 T`。 |

```java
34102-日志段：经测如下日志，可见特征可以越来越抽象。
特征类比结果 => Proto特征348：(0_11)
      - - - - - -
      - - * * * -
      - *     - -
- - * *   - *   -
- * *   - - * - -
- *   * * *   - -
- *   *           
- * - - * -       
- - - - - -       
Ass特征T302：((0_7:0_4))


   *      
 * *    * - -
 *     -  -
   *  * -  -
       *  
   - - -    
   - - -    
抽象特征T349：((0_11:(0_7:0_4)))


   *      
 * *     - -
 *     -  -
   *  * -  -
       *  
   - - -    
   - - -                   

```

```java
34103-日志段：如下实测日志，可见，可以识别到越来越抽象的结果，并且匹配度高（以下是训练了十几张左右的0图片的日志）。
 1113 [08:21:51:742 TI           TIUtils.m 416] 概念识别结果 (感似:0条 理似:10条 感交:0 理交:0) protoAlg:A56()
 1114 [08:21:51:742 TI           TIUtils.m 425] 概念识别到：A1 匹配度：1.00 input:0_2 result:0_2
 1115 [08:21:51:743 TI           TIUtils.m 425] 概念识别到：A56 匹配度：1.00 input:0_2 result:0_2
 1116 [08:21:51:743 TI           TIUtils.m 425] 概念识别到：A54 匹配度：0.96 input:0_2 result:(0_10:0_2)//附1
 1117 [08:21:51:743 TI           TIUtils.m 425] 概念识别到：A55 匹配度：0.92 input:0_2 result:(0_10:(0_13:0_2))
 1118 [08:21:51:744 TI           TIUtils.m 425] 概念识别到：A35 匹配度：0.92 input:0_2 result:(0_13:0_2)//附2
 1119 [08:21:51:744 TI           TIUtils.m 425] 概念识别到：A52 匹配度：0.91 input:0_2 result:(0_10:(0_12:0_2))
 1120 [08:21:51:745 TI           TIUtils.m 425] 概念识别到：A48 匹配度：0.86 input:0_2 result:(0_10:(0_6:(0_12:0_2)))
 1121 [08:21:51:745 TI           TIUtils.m 425] 概念识别到：A31 匹配度：0.83 input:0_2 result:(0_12:0_2)//附3
 1122 [08:21:51:746 TI           TIUtils.m 425] 概念识别到：A40 匹配度：0.81 input:0_2 result:(0_6:0_2)//附4
 1123 [08:21:51:746 TI           TIUtils.m 425] 概念识别到：A45 匹配度：0.78 input:0_2 result:(0_6:(0_12:0_2))
 //附1-4说明：上面四个附说明的日志，像0_2，0_10，0_12，0_6都可以匹配到它（但它不一定是最合理的抽象，有三级四级抽象，可能更能体现局部特征，这个要看后续SP训练来体现）。
```

**小结：本节前两个测试点测完了，第三个涉及展开强训工具，改动较大，转下节展开弄。**

***

## n34p11 多码特征回测C：手训和RL强训
`CreateTime 2025.04.02`

上节测试了`1、抽象多层 2、识别更准`，本节继续搞：`3、强训SP`，使之能够准确认定一个抽象特征在任务中的作用（准确认定特征的作用）。

| 34111 | RL快速训练方式：用强训工具-测试特征最终作用于时序的SP稳定性。 |
| --- | --- |
| 测试点3 | 强训工具做一下只有8号坚果可以吃，来获取更多的SP稳定性，来慢慢跑出它可以准确识别到8（其实是SP稳定的准确认定8）。 |
| FZ1041 | 学饿（直接饿3次，不给坚果，因为现在视觉坚果暂不支持距离，都是直接输入占满视角的Mnist图）`T`。 |
| FZ1042 | 直吃（直投随机号坚果，但只有x号能吃）`T`。 |
| 训练效果 | 训练完后，看下SP训练的效果，能不能让稳定的抽具象层级浮现。 |

| 34112 | 手动慢速训练方式：直接手动直投（从0_1到0_17依次直投），观察特征抽象和SP演化过程。 |
| --- | --- |
| 说明 | 上表RL训练方式太快，本表先手动慢慢训练下，以观察下过程中有没什么明显bug，并且可以在此过程中，了解下需要重点观察哪些数据变化。 |
| 测试点4 | 每次直投都自动取下一个0，然后看特征识别到类比抽象，再到SP值的变化。 |
| 结果 | 先测特征类比抽象和匹配度强度竞争就行，目前还用不着SP变化 `训练结果转34113 T`。 |

| 34113 | 手动慢速训练记录 |
| --- | --- |
| 说明 | 本次训练共训练了十几张0图片和十几张1图片，共产生抽象特征1500种左右，生成各种抽具象概念280多个，各种关联30000个左右，训练时长2分钟左右。 |
| 日志1 | 下图是一些抽象特征的可视化，第一张是0的左下角的弯曲，第二张是1的上下直线，有一些右上角的倾斜。 |
|  | 注1：任何一个抽象特征，它能匹配到许多种0或1等各数字的结果，但有一大堆抽象特征，分别能够匹配到各自的许多种数字结果。 |
|  | 注2：有一些特征过度具象，有一些过度抽象，这些过度的会在竞争中被慢慢淘汰掉。 |
|  | ![](assets/739_慢训Mnist0和1_A.png) |
|  | ![](assets/740_慢训Mnist0和1_B.png) |
| 日志2 | 下图是输入0几乎全识别到0的结果，输入1几乎全识别到1的结果。 |
|  | 注1：每一条都是由抽象特征来匹配的，比如0的弯，1的直。 |
|  | 注2：日志中`GV数`表示该特征内细节匹配数，`度`表示匹配度。 |
|  | ![](assets/741_慢训Mnist0和1_C.png) |
|  | ![](assets/742_慢训Mnist0和1_D.png) |
| 总结 | 以上可见，1和0准确度尚可，不过0里识别的还是有1的，并且是那种GV数很少的抽象特征。 |
| 疑问 | GV数很少的抽象特征，其实相当于局部特征了，比如：零的左下角的曲线，如果有6，8，0这三个数字的左下角都是一样的。 |

| 34114 | RL快速训练记录 |
| --- | --- |
| 步骤1 | 通过RL工具，把能吃的0号坚果训练100张，然后1-9各训练20张。 |
| 步骤2 | 然后用直投识别下测试图库，经测试结果日志如下： |
| 日志1 | 从日志分析，果然8和6和0是容易识别混的。 |
| 日志2 | 并且像1与7有过度抽象的特征，那也可能被识别成4，甚至写的直一些的2，3都有可能。 |
| 疑问 | 可见确实有抽象特征识别导致的不准确问题（参考以上日志1和2，以及34113-疑问）`转n34p13 T`。 |

***

## n34p12 多码特征回测D：特征最终作用于时序的SP稳定性
`CreateTime 2025.04.02`

总结：还没测到本节SP稳定性，就测到抽象特征太局部的问题了，转下节先做“组特征”。

***

## n34p13 从组特征 到 特征嵌套
`CreateTime 2025.04.09`

从上表34113和34114两个疑问可见，过度抽象导致识别不准确的问题，本节展开分析下。

| 34131 | 组特征之：起因 |
| --- | --- |
| 说明 | 从上表34113和34114两个疑问可见，过度抽象导致识别不准确的问题，本节展开分析下。 |
| 矛盾 | 单特征的局部特征规律多，容易抽象成稳定的抽象特征，但就无法匹配整体性。 |
|  | > 比如0的左下角的曲线，这个其实不算过度抽象，抽象特征注定不可能照顾特征的整体性，因为二者本来就是矛盾的。 |
| 方案 | 可以增加组特征，每个抽象（局部）特征之间判断位置相符度，相符度高的列为了组，做为一个组特征。 |
| 结果 | 本表制定了新加一个“组特征”的大方向，下表继续展开。 |

| 34132 | 组特征之：表征 |
| --- | --- |
| 方案1 | 组特征的表征：直接将概念的元素存为一个数组吗？ |
|  | > 缺点：一来性能不好，耦合度太高，二来也不利于组特征的复用。 |
| 方案2 | 将组特征独立成一个节点类型：AIGroupFeatureNode |
|  | > 优点：即宏微变成V-GV-T-GT-A-F共六层。 |
|  | > 缺点：方案2看起来简单，但事实上组特征的构建、识别、类比、抽象都要支持。 |
| 方案3 | 把Feature改成多个宏微层级，自动多层级。 |
|  | > 优点1：这样更可以自适合很细节与很整体的关系（即宏微变成V-GV-T...-A-F共五+层）。 |
|  | > 优点2：方案3其实更简单，它可以复用特征的构建，识别，类比，抽象等代码。 |
|  | > 缺点：有一些小缺点，这么做就需要在特征识别算法中，采用不断递归识别特征，性能上是会有一些影响的。 |
| 方案4 | 把GV、T、GT都整成多层嵌套的T。 |
|  | > 优点：这样更可以自适应和复用代码（即宏微变成V-T...-A-F共四+层）。 |
|  | > 缺点：方案4比方案3更彻底，但缺点是GV的索引和T还是有巨大不同的，不建议直接将GV归为T的一层。 |
| 抉择 | 其实不难分析，方案2乍一看比方案3简单，但细一想正好相反，方案3才更简单，大多代码可复用，所以暂选定方案3 `T`。 |
| 总结 | 在本表，由组特征的方案2，转向特征方案3，下表开始尝试方案3的工程实践。 |

| 34133 | 特征嵌套：工程实践 |
| --- | --- |

***

<br><br><br><br><br>
